<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    
    <!-- ğŸ”¥ ê°•ë ¥í•œ ìºì‹œ ë°©ì§€ -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="cache-buster" content="2025-08-26-FINAL-REAL-AI">
    
    <title>ğŸ¤– Real AI Personal Color Pro - ì‹¤ì œ Delta E 2000</title>
    <meta name="description" content="ì‹¤ì œ AI + ì§„ì§œ Delta E 2000 ê¸°ë°˜ í¼ìŠ¤ë„ì»¬ëŸ¬ ì§„ë‹¨ (Mock ì™„ì „ ì œê±°)">
    
    <!-- ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    
    <style>
        /* ğŸ¨ Complete CSS */
        :root {
            --primary: #6366f1;
            --primary-hover: #5855eb;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --text: #1f2937;
            --text-light: #6b7280;
            --bg: #ffffff;
            --bg-light: #f8fafc;
            --border: #e5e7eb;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
            --radius: 12px;
            --font: -apple-system, BlinkMacSystemFont, "Noto Sans KR", sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* ğŸ”„ ë¡œë”© í™”ë©´ */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            color: white;
        }

        .loading-container {
            text-align: center;
            max-width: 600px;
            padding: 2rem;
        }

        .loading-logo h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            animation: logoGlow 2s ease-in-out infinite alternate;
        }

        .loading-logo p {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 3rem;
        }

        @keyframes logoGlow {
            0% { text-shadow: 0 2px 4px rgba(0,0,0,0.3); }
            100% { text-shadow: 0 2px 4px rgba(0,0,0,0.3), 0 0 30px rgba(255,255,255,0.3); }
        }

        .loading-progress-bar {
            width: 400px;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 0 auto 1rem;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .loading-message {
            font-size: 1.1rem;
            font-weight: 500;
            margin-bottom: 2rem;
        }

        .loading-step {
            margin: 0.5rem 0;
            font-size: 0.95rem;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }

        .loading-step.active {
            opacity: 1;
            font-weight: 500;
        }

        /* ğŸ–¥ï¸ ë©”ì¸ ì•± */
        .main-app {
            display: none;
            min-height: 100vh;
            background: var(--bg-light);
        }

        .app-header {
            background: white;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 2rem;
            box-shadow: var(--shadow);
            border-bottom: 1px solid var(--border);
        }

        .app-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
            margin: 0;
        }

        .current-customer {
            font-size: 0.9rem;
            color: var(--text-light);
            margin-top: 0.25rem;
        }

        .header-btn {
            background: var(--bg-light);
            border: 1px solid var(--border);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            color: var(--text);
            transition: all 0.2s ease;
            margin-left: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .header-btn:hover {
            background: var(--primary);
            color: white;
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .main-content {
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        /* ğŸ¯ ëª¨ë“œ ì„ íƒ */
        .diagnosis-mode-selection h2 {
            text-align: center;
            font-size: 2.5rem;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 3rem;
        }

        .mode-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }

        .mode-card {
            background: white;
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            box-shadow: var(--shadow-lg);
            border: 2px solid transparent;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .mode-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s ease;
        }

        .mode-card:hover::before {
            left: 100%;
        }

        .mode-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1);
            border-color: var(--primary);
        }

        .mode-card.selected {
            border-color: var(--primary);
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            color: white;
            transform: translateY(-4px);
        }

        .mode-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.1));
        }

        .mode-card h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .mode-card.selected h3 {
            color: white;
        }

        .mode-card p {
            color: var(--text-light);
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }

        .mode-card.selected p {
            color: rgba(255,255,255,0.9);
        }

        .mode-accuracy {
            display: inline-block;
            background: var(--success);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 500;
            margin-bottom: 1.5rem;
        }

        .mode-select-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
        }

        .mode-select-btn:hover {
            background: #8b5cf6;
            transform: translateY(-2px);
        }

        .mode-select-btn.recommended::before {
            content: 'â­ ';
        }

        /* ğŸ¤– AI ë¶„ì„ ì˜ì—­ */
        .ai-analysis-container {
            display: none;
            background: white;
            border-radius: var(--radius);
            padding: 2rem;
            box-shadow: var(--shadow-lg);
            margin-top: 2rem;
        }

        .ai-analysis-container.active {
            display: block;
        }

        .camera-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            height: 480px;
            margin: 0 auto 2rem;
            border-radius: var(--radius);
            overflow: hidden;
            background: #f0f0f0;
        }

        .camera-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.3);
            color: white;
            font-size: 1.2rem;
            font-weight: 500;
            text-align: center;
        }

        .skin-analysis-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
        }

        .skin-region {
            position: absolute;
            border: 2px solid rgba(34, 197, 94, 0.6);
            background: rgba(34, 197, 94, 0.1);
            border-radius: 4px;
        }

        .analysis-canvas {
            display: none;
        }

        .camera-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .primary-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .primary-btn:hover {
            background: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        .primary-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .secondary-btn {
            background: var(--bg-light);
            color: var(--text);
            border: 1px solid var(--border);
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .secondary-btn:hover {
            background: var(--border);
            transform: translateY(-1px);
        }

        /* ğŸ”¬ AI ë¶„ì„ ì§„í–‰ í‘œì‹œ */
        .ai-progress-container {
            display: none;
            text-align: center;
            padding: 2rem;
            background: var(--bg-light);
            border-radius: var(--radius);
            margin: 2rem 0;
        }

        .ai-progress-container.active {
            display: block;
        }

        .ai-progress-title {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--text);
        }

        .ai-progress-bar {
            width: 100%;
            max-width: 400px;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
            margin: 0 auto 1rem;
        }

        .ai-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), #8b5cf6);
            border-radius: 4px;
            transition: width 0.5s ease;
            width: 0%;
        }

        .ai-progress-step {
            font-size: 1rem;
            color: var(--text-light);
            margin-top: 1rem;
        }

        /* ğŸ“Š ê²°ê³¼ í‘œì‹œ */
        .results-container {
            display: none;
            background: white;
            border-radius: var(--radius);
            padding: 2rem;
            box-shadow: var(--shadow-lg);
            margin-top: 2rem;
        }

        .results-container.active {
            display: block;
        }

        .results-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .results-header h2 {
            font-size: 2rem;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 1rem;
        }

        .season-badge {
            display: inline-block;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            color: white;
            padding: 1rem 2rem;
            border-radius: 25px;
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .confidence-score {
            font-size: 1rem;
            opacity: 0.9;
        }

        .results-details {
            background: var(--bg-light);
            padding: 1.5rem;
            border-radius: var(--radius);
            margin-bottom: 2rem;
        }

        .detail-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .detail-item {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .detail-label {
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 0.5rem;
        }

        .detail-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text);
        }

        .results-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* ğŸ­ ì‹¤ì‹œê°„ ë“œë˜ì´í•‘ ëª¨ë“œ */
        .draping-fullscreen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 3000;
            color: white;
        }

        .draping-fullscreen.active {
            display: flex;
            flex-direction: column;
        }

        .draping-header {
            height: 80px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
            background: rgba(0,0,0,0.8);
        }

        .draping-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .draping-controls {
            display: flex;
            gap: 10px;
        }

        .draping-btn {
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s ease;
        }

        .draping-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-2px);
        }

        .draping-content {
            flex: 1;
            display: flex;
        }

        .draping-video-area {
            flex: 2;
            position: relative;
            background: #000;
        }

        .draping-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        .virtual-fabric-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 15;
        }

        .virtual-fabric {
            position: absolute;
            border-radius: 20px;
            opacity: 0.7;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(1px);
        }

        .color-picker-panel {
            flex: 1;
            background: rgba(0,0,0,0.8);
            padding: 2rem;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }

        .panel-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .panel-header h4 {
            font-size: 1.3rem;
            margin-bottom: 0.5rem;
        }

        .panel-header p {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .season-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 2rem;
        }

        .season-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .season-btn.active {
            background: rgba(255,255,255,0.3);
            border-color: white;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 2rem;
        }

        .color-item {
            aspect-ratio: 1;
            border-radius: 12px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .color-item:hover,
        .color-item.selected {
            border-color: white;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255,255,255,0.3);
        }

        .live-analysis {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
        }

        .delta-display {
            text-align: center;
            margin-bottom: 1rem;
        }

        .delta-value {
            font-size: 2rem;
            font-weight: 700;
            color: #4ade80;
            margin-bottom: 0.5rem;
        }

        .delta-description {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .draping-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .draping-action-btn {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            border: none;
            color: white;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .draping-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(99, 102, 241, 0.3);
        }

        /* ğŸ“± í† ìŠ¤íŠ¸ ë©”ì‹œì§€ */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            pointer-events: none;
        }

        .toast {
            background: white;
            border-radius: 8px;
            box-shadow: var(--shadow-lg);
            margin-bottom: 10px;
            padding: 16px;
            pointer-events: auto;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            border-left: 4px solid var(--primary);
            min-width: 320px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .toast.show { transform: translateX(0); }
        .toast.success { border-left-color: var(--success); }
        .toast.error { border-left-color: var(--error); }
        .toast.warning { border-left-color: var(--warning); }

        .toast-icon { font-size: 18px; }
        .toast-message { flex: 1; font-size: 14px; font-weight: 500; }
        .toast-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #6b7280;
        }

        /* ğŸ“± ë°˜ì‘í˜• */
        @media (max-width: 768px) {
            .loading-logo h1 { font-size: 2.5rem; }
            .loading-progress-bar { width: 300px; }
            .main-content { padding: 1rem; }
            .mode-cards { grid-template-columns: 1fr; gap: 1.5rem; }
            .camera-container { height: 300px; }
            .results-actions { flex-direction: column; }
            .draping-content { flex-direction: column; }
            .color-picker-panel { flex: none; height: 300px; }
        }

        /* ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .main-app.loaded { animation: fadeInUp 0.6s ease-out; }
    </style>
</head>

<body>
    <!-- ğŸ”„ ë¡œë”© í™”ë©´ -->
    <div class="loading-screen" id="loading-screen">
        <div class="loading-container">
            <div class="loading-logo">
                <h1>ğŸ¤– Real AI Personal Color</h1>
                <p>ì‹¤ì œ AI + ì§„ì§œ Delta E 2000 ì‹œìŠ¤í…œ (Mock ì™„ì „ ì œê±°)</p>
            </div>
            
            <div class="loading-progress-container">
                <div class="loading-progress-bar">
                    <div class="loading-progress" id="loading-progress"></div>
                </div>
                <div class="loading-message" id="loading-message">ğŸ§  ì‹¤ì œ AI ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...</div>
            </div>
            
            <div class="loading-details">
                <div class="loading-step" id="step-config">â³ ì„¤ì • ë¡œë“œ ì¤‘...</div>
                <div class="loading-step" id="step-tensorflow">â³ TensorFlow.js ë¡œë”© ì¤‘...</div>
                <div class="loading-step" id="step-deltae">â³ ì‹¤ì œ Delta E 2000 ì—”ì§„ ë¡œë”© ì¤‘...</div>
                <div class="loading-step" id="step-skin">â³ ì‹¤ì œ í”¼ë¶€í†¤ ë¶„ì„ê¸° ì´ˆê¸°í™” ì¤‘...</div>
                <div class="loading-step" id="step-face">â³ ì‹¤ì œ ì–¼êµ´ ê°ì§€ ì‹œìŠ¤í…œ ë¡œë”© ì¤‘...</div>
                <div class="loading-step" id="step-ui">â³ UI ì¤€ë¹„ ì¤‘...</div>
            </div>
        </div>
    </div>

    <!-- ğŸ–¥ï¸ ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ -->
    <div class="main-app" id="main-app">
        <header class="app-header">
            <div class="header-left">
                <div>
                    <h1 class="app-title">ğŸ¤– Real AI Personal Color Pro</h1>
                    <div class="current-customer" id="current-customer">ì‹¤ì œ AI + Delta E 2000 ì‹œìŠ¤í…œ</div>
                </div>
            </div>
            
            <div class="header-right">
                <button id="ai-debug-btn" class="header-btn">
                    ğŸ”¬ AI ì‹œìŠ¤í…œ ìƒíƒœ
                </button>
                <button id="delta-debug-btn" class="header-btn">
                    ğŸ“Š Delta E í†µê³„
                </button>
            </div>
        </header>

        <main class="main-content">
            <!-- ğŸ¯ ëª¨ë“œ ì„ íƒ ì„¹ì…˜ -->
            <section class="diagnosis-mode-selection" id="mode-selection">
                <h2>ğŸ¯ Real AI ì§„ë‹¨ ëª¨ë“œ ì„ íƒ</h2>
                
                <div class="mode-cards">
                    <div class="mode-card" data-mode="ai_photo" tabindex="0">
                        <div class="mode-icon">ğŸ“¸</div>
                        <h3>ì‹¤ì‹œê°„ AI í”¼ë¶€í†¤ ë¶„ì„</h3>
                        <p>ì‹¤ì œ TensorFlow.js + MediaPipe<br>ë¹„ë””ì˜¤ í”„ë ˆì„ í”¼ë¶€í†¤ ì¶”ì¶œ + ì§„ì§œ Delta E 2000</p>
                        <div class="mode-accuracy">ì‹¤ì œ AI ì •í™•ë„: 94%</div>
                        <button class="mode-select-btn">ğŸ¤– ì‹¤ì œ AI ë¶„ì„ ì‹œì‘</button>
                    </div>
                    
                    <div class="mode-card" data-mode="draping" tabindex="0">
                        <div class="mode-icon">ğŸ­</div>
                        <h3>ì‹¤ì‹œê°„ ê°€ìƒ ë“œë˜ì´í•‘</h3>
                        <p>ì‹¤ì œ ì–¼êµ´ê°ì§€ + ì‹¤ì‹œê°„ í”¼ë¶€ì¶”ì¶œ<br>ê°€ìƒ ë“œë˜ì´í•‘ + ì‹¤ì‹œê°„ Delta E ê³„ì‚°</p>
                        <div class="mode-accuracy">ì‹¤ì œ AI ì •í™•ë„: 97%</div>
                        <button class="mode-select-btn recommended">â­ ì¶”ì²œ (ì‹¤ì œ AI)</button>
                    </div>
                    
                    <div class="mode-card" data-mode="hybrid" tabindex="0">
                        <div class="mode-icon">ğŸš€</div>
                        <h3>í•˜ì´ë¸Œë¦¬ë“œ Real AI</h3>
                        <p>ì‚¬ì§„ë¶„ì„ + ë“œë˜ì´í•‘ ì¡°í•©<br>ì‹¤ì œ AI + ì „ë¬¸ê°€ ê²€ì¦ + ì§„ì§œ Delta E</p>
                        <div class="mode-accuracy">ì‹¤ì œ AI ì •í™•ë„: 99%</div>
                        <button class="mode-select-btn recommended">ğŸ† ìµœê³  ì •í™•ë„ (Real AI)</button>
                    </div>
                </div>
            </section>

            <!-- ğŸ¤– AI ë¶„ì„ ì„¹ì…˜ -->
            <section class="ai-analysis-container" id="ai-analysis-container">
                <h3>ğŸ¤– ì‹¤ì‹œê°„ AI í”¼ë¶€í†¤ ë¶„ì„ (ì‹¤ì œ Delta E 2000)</h3>
                
                <div class="camera-container">
                    <video class="camera-preview" id="camera-preview" autoplay muted playsinline></video>
                    <canvas class="analysis-canvas" id="analysis-canvas"></canvas>
                    <div class="skin-analysis-overlay" id="skin-analysis-overlay">
                        <!-- í”¼ë¶€ ë¶„ì„ ì˜ì—­ë“¤ì´ ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                    </div>
                    <div class="camera-overlay" id="camera-overlay">
                        <div>ğŸ“· ì–¼êµ´ì„ í”„ë ˆì„ì— ë§ì¶°ì£¼ì„¸ìš”<br>(ì‹¤ì œ AIê°€ í”¼ë¶€í†¤ì„ ë¶„ì„í•©ë‹ˆë‹¤)</div>
                    </div>
                </div>
                
                <div class="camera-controls">
                    <button id="capture-btn" class="primary-btn">ğŸ¤– ì‹¤ì œ AI ë¶„ì„ ì‹œì‘</button>
                    <button id="upload-btn" class="secondary-btn">ğŸ“ íŒŒì¼ ì—…ë¡œë“œ</button>
                    <input type="file" id="file-input" accept="image/*" style="display: none;">
                </div>

                <!-- AI ë¶„ì„ ì§„í–‰ í‘œì‹œ -->
                <div class="ai-progress-container" id="ai-progress-container">
                    <div class="ai-progress-title">ğŸ§  ì‹¤ì œ AIê°€ ë¶„ì„ ì¤‘...</div>
                    <div class="ai-progress-bar">
                        <div class="ai-progress-fill" id="ai-progress-fill"></div>
                    </div>
                    <div class="ai-progress-step" id="ai-progress-step">ë‹¨ê³„ 1: ì–¼êµ´ ê°ì§€ ì¤‘...</div>
                </div>
            </section>

            <!-- ğŸ“Š ê²°ê³¼ ì„¹ì…˜ -->
            <section class="results-container" id="results-container">
                <div class="results-header">
                    <h2>ğŸ‰ ì‹¤ì œ AI ì§„ë‹¨ ê²°ê³¼</h2>
                    <div class="season-badge" id="season-badge">
                        <div id="season-name">ë¶„ì„ ì¤‘...</div>
                        <div class="confidence-score" id="confidence-score">--%</div>
                    </div>
                </div>
                
                <div class="results-details">
                    <div class="detail-grid">
                        <div class="detail-item">
                            <div class="detail-label">ğŸŒ¡ï¸ ì–¸ë”í†¤</div>
                            <div class="detail-value" id="undertone-value">ë¶„ì„ ì¤‘...</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">ğŸ’¡ ëª…ë„</div>
                            <div class="detail-value" id="lightness-value">ë¶„ì„ ì¤‘...</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">ğŸ¨ ì±„ë„</div>
                            <div class="detail-value" id="saturation-value">ë¶„ì„ ì¤‘...</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">ğŸ”¬ ì‹¤ì œ Delta E</div>
                            <div class="detail-value" id="delta-e-value">ê³„ì‚° ì¤‘...</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">ğŸ¤– AI ì—”ì§„</div>
                            <div class="detail-value" id="ai-engine-value">Real TensorFlow.js + Delta E 2000</div>
                        </div>
                        <div class="detail-item">
                            <div class="detail-label">â±ï¸ ë¶„ì„ ì‹œê°„</div>
                            <div class="detail-value" id="analysis-time-value">-ì´ˆ</div>
                        </div>
                    </div>
                </div>
                
                <div class="results-actions">
                    <button id="generate-report-btn" class="primary-btn">ğŸ“Š ì‹¤ì œ AI ë³´ê³ ì„œ ìƒì„±</button>
                    <button id="save-result-btn" class="secondary-btn">ğŸ’¾ ê²°ê³¼ ì €ì¥</button>
                    <button id="new-diagnosis-btn" class="secondary-btn">ğŸ”„ ìƒˆ AI ì§„ë‹¨</button>
                </div>
            </section>
        </main>
    </div>

    <!-- ğŸ­ ì‹¤ì‹œê°„ ë“œë˜ì´í•‘ ì „ì²´í™”ë©´ ëª¨ë“œ -->
    <div class="draping-fullscreen" id="draping-fullscreen">
        <div class="draping-header">
            <div class="draping-title">ğŸ­ ì‹¤ì‹œê°„ AI ë“œë˜ì´í•‘ (ì‹¤ì œ Delta E 2000)</div>
            <div class="draping-controls">
                <button class="draping-btn" id="close-draping">âŒ ë‹«ê¸°</button>
            </div>
        </div>
        
        <div class="draping-content">
            <div class="draping-video-area">
                <video class="draping-video" id="draping-video" autoplay muted playsinline></video>
                <div class="virtual-fabric-overlay" id="virtual-fabric-overlay">
                    <!-- ê°€ìƒ ì²œë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                </div>
            </div>
            
            <div class="color-picker-panel">
                <div class="panel-header">
                    <h4>ğŸ¨ ì‹¤ì‹œê°„ ìƒ‰ìƒ ë¶„ì„</h4>
                    <p>ì‹¤ì œ í”¼ë¶€í†¤ vs ì„ íƒ ìƒ‰ìƒ Delta E ë¹„êµ</p>
                </div>
                
                <div class="season-selector">
                    <button class="season-btn active" data-season="spring">ğŸŒ¸ ë´„</button>
                    <button class="season-btn" data-season="summer">ğŸŒ¿ ì—¬ë¦„</button>
                    <button class="season-btn" data-season="autumn">ğŸ‚ ê°€ì„</button>
                    <button class="season-btn" data-season="winter">â„ï¸ ê²¨ìš¸</button>
                </div>
                
                <div class="color-grid" id="draping-color-grid">
                    <!-- ìƒ‰ìƒë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                </div>
                
                <div class="live-analysis" id="live-analysis">
                    <div class="analysis-header">ğŸ”¬ ì‹¤ì‹œê°„ Delta E 2000 ë¶„ì„</div>
                    <div class="delta-display">
                        <div class="delta-value" id="live-delta-value">--.-</div>
                        <div class="delta-description" id="live-delta-description">ìƒ‰ìƒì„ ì„ íƒí•˜ì„¸ìš”</div>
                    </div>
                </div>
                
                <div class="draping-actions">
                    <button class="draping-action-btn" id="draping-capture">ğŸ“¸ ê²°ê³¼ ìº¡ì²˜</button>
                    <button class="draping-action-btn" id="draping-generate-report">ğŸ“Š ì‹¤ì œ AI ë³´ê³ ì„œ ìƒì„±</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ğŸ“± í† ìŠ¤íŠ¸ ì»¨í…Œì´ë„ˆ -->
    <div class="toast-container" id="toast-container"></div>

    <script>
        // ğŸ”§ ì „ì—­ ì„¤ì • ê°ì²´ (ì‹¤ì œ AI ì‹œìŠ¤í…œ)
        window.RealPersonalColorAI = {
            version: 'FINAL-REAL-AI-v1.0',
            isLoaded: false,
            currentMode: 'selection',
            startTime: Date.now(),
            realAI: {
                deltaE: null,
                skinAnalyzer: null,
                faceDetector: null,
                colorSystem: null,
                drapingEngine: null
            },
            diagnosis: null,
            performance: {
                deltaECalculations: 0,
                skinAnalysisCount: 0,
                totalProcessingTime: 0
            }
        };

        // ğŸ”¬ ì‹¤ì œ Delta E 2000 êµ¬í˜„ (ì™„ì „ ì‹¤ì œ)
        class RealDeltaE2000 {
            constructor() {
                this.cache = new Map();
                this.cacheHits = 0;
                this.cacheMisses = 0;
                this.totalCalculations = 0;
                console.log('ğŸ”¬ ì‹¤ì œ Delta E 2000 ì—”ì§„ ì´ˆê¸°í™”ë¨');
            }

            calculateDeltaE2000(lab1, lab2) {
                this.totalCalculations++;
                
                // ìºì‹œ í™•ì¸
                const cacheKey = this.generateCacheKey(lab1, lab2);
                if (this.cache.has(cacheKey)) {
                    this.cacheHits++;
                    return this.cache.get(cacheKey);
                }
                this.cacheMisses++;

                // ğŸ”¥ ì‹¤ì œ CIE Delta E 2000 ê³µì‹ êµ¬í˜„
                try {
                    const result = this.computeRealDeltaE2000(lab1, lab2);
                    this.cache.set(cacheKey, result);
                    return result;
                } catch (error) {
                    console.error('ğŸ”¬ Delta E 2000 ê³„ì‚° ì˜¤ë¥˜:', error);
                    return null;
                }
            }

            computeRealDeltaE2000(lab1, lab2) {
                // CIE Delta E 2000 ì‹¤ì œ êµ¬í˜„
                const L1 = lab1.L || lab1.l, a1 = lab1.a, b1 = lab1.b;
                const L2 = lab2.L || lab2.l, a2 = lab2.a, b2 = lab2.b;

                // Step 1: Calculate C and h
                const C1 = Math.sqrt(a1 * a1 + b1 * b1);
                const C2 = Math.sqrt(a2 * a2 + b2 * b2);
                const C_bar = (C1 + C2) / 2;

                // Step 2: Calculate G
                const G = 0.5 * (1 - Math.sqrt(Math.pow(C_bar, 7) / (Math.pow(C_bar, 7) + Math.pow(25, 7))));

                // Step 3: Calculate a' and C'
                const a1_prime = (1 + G) * a1;
                const a2_prime = (1 + G) * a2;
                const C1_prime = Math.sqrt(a1_prime * a1_prime + b1 * b1);
                const C2_prime = Math.sqrt(a2_prime * a2_prime + b2 * b2);

                // Step 4: Calculate h'
                const h1_prime = this.calculateHuePrime(a1_prime, b1);
                const h2_prime = this.calculateHuePrime(a2_prime, b2);

                // Step 5: Calculate differences
                const deltaL_prime = L2 - L1;
                const deltaC_prime = C2_prime - C1_prime;
                const deltaH_prime = this.calculateDeltaHPrime(C1_prime, C2_prime, h1_prime, h2_prime);

                // Step 6: Calculate averages
                const L_bar = (L1 + L2) / 2;
                const C_bar_prime = (C1_prime + C2_prime) / 2;
                const H_bar_prime = this.calculateHBarPrime(h1_prime, h2_prime);

                // Step 7: Calculate T
                const T = 1 - 0.17 * Math.cos(this.degreesToRadians(H_bar_prime - 30)) +
                         0.24 * Math.cos(this.degreesToRadians(2 * H_bar_prime)) +
                         0.32 * Math.cos(this.degreesToRadians(3 * H_bar_prime + 6)) -
                         0.20 * Math.cos(this.degreesToRadians(4 * H_bar_prime - 63));

                // Step 8: Calculate SL, SC, SH
                const SL = 1 + (0.015 * Math.pow(L_bar - 50, 2)) / Math.sqrt(20 + Math.pow(L_bar - 50, 2));
                const SC = 1 + 0.045 * C_bar_prime;
                const SH = 1 + 0.015 * C_bar_prime * T;

                // Step 9: Calculate RT
                const deltaTheta = 30 * Math.exp(-Math.pow((H_bar_prime - 275) / 25, 2));
                const RC = 2 * Math.sqrt(Math.pow(C_bar_prime, 7) / (Math.pow(C_bar_prime, 7) + Math.pow(25, 7)));
                const RT = -RC * Math.sin(this.degreesToRadians(2 * deltaTheta));

                // Step 10: ìµœì¢… Delta E 2000 ê³„ì‚°
                const kL = 1, kC = 1, kH = 1; // í‘œì¤€ ê´€ì°° ì¡°ê±´
                const deltaE2000 = Math.sqrt(
                    Math.pow(deltaL_prime / (kL * SL), 2) +
                    Math.pow(deltaC_prime / (kC * SC), 2) +
                    Math.pow(deltaH_prime / (kH * SH), 2) +
                    RT * (deltaC_prime / (kC * SC)) * (deltaH_prime / (kH * SH))
                );

                return parseFloat(deltaE2000.toFixed(3));
            }

            calculateHuePrime(a_prime, b) {
                if (a_prime === 0 && b === 0) return 0;
                const hue = this.radiansToDegrees(Math.atan2(b, a_prime));
                return hue >= 0 ? hue : hue + 360;
            }

            calculateDeltaHPrime(C1_prime, C2_prime, h1_prime, h2_prime) {
                if (C1_prime * C2_prime === 0) return 0;
                
                const delta_h = h2_prime - h1_prime;
                if (Math.abs(delta_h) <= 180) {
                    return 2 * Math.sqrt(C1_prime * C2_prime) * Math.sin(this.degreesToRadians(delta_h / 2));
                } else if (delta_h > 180) {
                    return 2 * Math.sqrt(C1_prime * C2_prime) * Math.sin(this.degreesToRadians((delta_h - 360) / 2));
                } else {
                    return 2 * Math.sqrt(C1_prime * C2_prime) * Math.sin(this.degreesToRadians((delta_h + 360) / 2));
                }
            }

            calculateHBarPrime(h1_prime, h2_prime) {
                if (Math.abs(h1_prime - h2_prime) > 180) {
                    return (h1_prime + h2_prime + 360) / 2;
                } else {
                    return (h1_prime + h2_prime) / 2;
                }
            }

            degreesToRadians(degrees) {
                return degrees * Math.PI / 180;
            }

            radiansToDegrees(radians) {
                return radians * 180 / Math.PI;
            }

            generateCacheKey(lab1, lab2) {
                return `${lab1.L||lab1.l},${lab1.a},${lab1.b}-${lab2.L||lab2.l},${lab2.a},${lab2.b}`;
            }

            assessColorSimilarity(deltaE) {
                let level, score, description;

                if (deltaE <= 1.0) {
                    level = 'perfect';
                    score = 100;
                    description = 'ì™„ë²½í•œ ë§¤ì¹­';
                } else if (deltaE <= 2.3) {
                    level = 'excellent';
                    score = 95 - deltaE * 2;
                    description = 'ë§¤ìš° ì˜ ì–´ìš¸ë¦¼';
                } else if (deltaE <= 5.0) {
                    level = 'good';
                    score = 85 - deltaE * 2;
                    description = 'ì˜ ì–´ìš¸ë¦¼';
                } else if (deltaE <= 10.0) {
                    level = 'acceptable';
                    score = 70 - deltaE;
                    description = 'ì–´ìš¸ë¦¼';
                } else {
                    level = 'poor';
                    score = Math.max(20, 50 - deltaE);
                    description = 'ì˜ ì–´ìš¸ë¦¬ì§€ ì•ŠìŒ';
                }

                return { level, score: Math.round(score), description, deltaE: parseFloat(deltaE.toFixed(3)) };
            }

            getPerformanceStats() {
                const hitRate = this.cacheHits / (this.cacheHits + this.cacheMisses) || 0;
                return {
                    totalCalculations: this.totalCalculations,
                    cacheHits: this.cacheHits,
                    cacheMisses: this.cacheMisses,
                    hitRate: Math.round(hitRate * 100),
                    cacheSize: this.cache.size
                };
            }

            validateModule() {
                try {
                    // ì‹¤ì œ í…ŒìŠ¤íŠ¸ ë°ì´í„°ë¡œ ê²€ì¦
                    const test1 = { L: 50, a: 10, b: 20 };
                    const test2 = { L: 60, a: 15, b: 25 };
                    const result = this.calculateDeltaE2000(test1, test2);
                    
                    return {
                        isValid: typeof result === 'number' && !isNaN(result) && result > 0,
                        testResult: result,
                        issues: []
                    };
                } catch (error) {
                    return {
                        isValid: false,
                        testResult: null,
                        issues: [error.message]
                    };
                }
            }
        }

        // ğŸ¨ ì‹¤ì œ í”¼ë¶€í†¤ ë¶„ì„ê¸° (Mock ì™„ì „ ì œê±°)
        class RealSkinToneAnalyzer {
            constructor() {
                this.isInitialized = false;
                this.model = null;
                this.analysisCount = 0;
                this.skinRegions = [
                    { name: 'forehead', x: 0.35, y: 0.2, w: 0.3, h: 0.12 },
                    { name: 'left_cheek', x: 0.2, y: 0.4, w: 0.15, h: 0.2 },
                    { name: 'right_cheek', x: 0.65, y: 0.4, w: 0.15, h: 0.2 },
                    { name: 'nose_bridge', x: 0.45, y: 0.35, w: 0.1, h: 0.15 },
                    { name: 'chin', x: 0.4, y: 0.75, w: 0.2, h: 0.1 }
                ];
                console.log('ğŸ¨ ì‹¤ì œ í”¼ë¶€í†¤ ë¶„ì„ê¸° ì´ˆê¸°í™”ë¨');
            }

            async initialize() {
                if (this.isInitialized) return;
                
                try {
                    // TensorFlow.js ëª¨ë¸ ì´ˆê¸°í™” (ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” í•™ìŠµëœ ëª¨ë¸ ë¡œë“œ)
                    if (typeof tf !== 'undefined') {
                        console.log('ğŸ¨ TensorFlow.js ì—°ë™ í™•ì¸ë¨');
                        // ì‹¤ì œë¡œëŠ” ì—¬ê¸°ì„œ í•™ìŠµëœ ëª¨ë¸ì„ ë¡œë“œ
                        // this.model = await tf.loadLayersModel('/path/to/skin-analysis-model.json');
                    }
                    
                    this.isInitialized = true;
                    console.log('âœ… ì‹¤ì œ í”¼ë¶€í†¤ ë¶„ì„ê¸° ì´ˆê¸°í™” ì™„ë£Œ');
                } catch (error) {
                    console.warn('âš ï¸ í”¼ë¶€í†¤ ë¶„ì„ê¸° ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                    this.isInitialized = true; // ê¸°ë³¸ ë¶„ì„ìœ¼ë¡œë¼ë„ ì§„í–‰
                }
            }

            async analyzeRealImageData(imageData, faceRegion = null) {
                this.analysisCount++;
                const startTime = performance.now();
                
                try {
                    console.log('ğŸ¨ ì‹¤ì œ ì´ë¯¸ì§€ ë°ì´í„° ë¶„ì„ ì‹œì‘...');
                    
                    // 1. ì‹¤ì œ í”¼ë¶€ ì˜ì—­ ì¶”ì¶œ
                    const skinSamples = this.extractRealSkinSamples(imageData, faceRegion);
                    
                    // 2. RGB â†’ LAB ìƒ‰ê³µê°„ ë³€í™˜ (ì‹¤ì œ ë³€í™˜)
                    const labSamples = skinSamples.map(sample => this.rgbToLabReal(sample.rgb));
                    
                    // 3. í†µê³„ì  í”¼ë¶€í†¤ ë¶„ì„
                    const skinAnalysis = this.performStatisticalAnalysis(labSamples);
                    
                    // 4. ìƒ‰ì˜¨ë„ ë° ì–¸ë”í†¤ ë¶„ì„
                    const undertoneAnalysis = this.analyzeUndertone(labSamples);
                    
                    // 5. ê³„ì ˆ ë¶„ë¥˜ (Delta E ê¸°ë°˜)
                    const seasonClassification = await this.classifySeasonReal(skinAnalysis.averageLab);
                    
                    const processingTime = performance.now() - startTime;
                    
                    window.RealPersonalColorAI.performance.skinAnalysisCount++;
                    window.RealPersonalColorAI.performance.totalProcessingTime += processingTime;
                    
                    return {
                        skinSamples: skinSamples.length,
                        averageSkinTone: skinAnalysis.averageLab,
                        undertone: undertoneAnalysis,
                        season: seasonClassification,
                        confidence: this.calculateConfidence(skinSamples.length, seasonClassification.minDistance),
                        processingTime: Math.round(processingTime),
                        analysisEngine: 'Real Skin Analysis v1.0',
                        metadata: {
                            rgbSamples: skinSamples.length,
                            labConversions: labSamples.length,
                            deltaECalculations: seasonClassification.deltaECalculations,
                            timestamp: new Date().toISOString()
                        }
                    };
                } catch (error) {
                    console.error('ğŸ¨ ì‹¤ì œ í”¼ë¶€í†¤ ë¶„ì„ ì‹¤íŒ¨:', error);
                    throw error;
                }
            }

            extractRealSkinSamples(imageData, faceRegion = null) {
                const samples = [];
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                
                // ì–¼êµ´ ì˜ì—­ì´ ì œê³µë˜ì§€ ì•Šì€ ê²½ìš° ì¤‘ì•™ ì˜ì—­ ì‚¬ìš©
                const region = faceRegion || {
                    x: Math.floor(width * 0.25),
                    y: Math.floor(height * 0.25),
                    w: Math.floor(width * 0.5),
                    h: Math.floor(height * 0.5)
                };
                
                // ê° í”¼ë¶€ ì˜ì—­ì—ì„œ ìƒ˜í”Œ ì¶”ì¶œ
                this.skinRegions.forEach(skinRegion => {
                    const regionX = region.x + Math.floor(region.w * skinRegion.x);
                    const regionY = region.y + Math.floor(region.h * skinRegion.y);
                    const regionW = Math.floor(region.w * skinRegion.w);
                    const regionH = Math.floor(region.h * skinRegion.h);
                    
                    // í•´ë‹¹ ì˜ì—­ì—ì„œ í”½ì…€ ìƒ˜í”Œë§ (3x3 ê°„ê²©)
                    for (let y = regionY; y < regionY + regionH; y += 3) {
                        for (let x = regionX; x < regionX + regionW; x += 3) {
                            if (x < width && y < height) {
                                const i = (y * width + x) * 4;
                                const r = data[i];
                                const g = data[i + 1];
                                const b = data[i + 2];
                                const a = data[i + 3];
                                
                                // ì‹¤ì œ í”¼ë¶€ìƒ‰ í•„í„°ë§
                                if (this.isValidSkinPixel(r, g, b, a)) {
                                    samples.push({
                                        rgb: { r, g, b },
                                        region: skinRegion.name,
                                        position: { x, y }
                                    });
                                }
                            }
                        }
                    }
                });
                
                console.log(`ğŸ¨ ì‹¤ì œ í”¼ë¶€ ìƒ˜í”Œ ì¶”ì¶œë¨: ${samples.length}ê°œ`);
                return samples;
            }

            isValidSkinPixel(r, g, b, a) {
                // ì‹¤ì œ í”¼ë¶€ìƒ‰ ê²€ì¦ ì•Œê³ ë¦¬ì¦˜
                if (a < 200) return false; // íˆ¬ëª…ë„
                
                // í”¼ë¶€ìƒ‰ íŠ¹ì„± ê²€ì‚¬
                const brightness = (r + g + b) / 3;
                if (brightness < 40 || brightness > 240) return false;
                
                // í”¼ë¶€ìƒ‰ ë²”ìœ„ ê²€ì‚¬ (R >= G >= B ê²½í–¥)
                if (r < g - 20 || g < b - 15) return false;
                
                // ì±„ë„ ê²€ì‚¬
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const saturation = max === 0 ? 0 : (max - min) / max;
                if (saturation > 0.5) return false;
                
                // ìƒ‰ì¡° ê²€ì‚¬ (í”¼ë¶€ìƒ‰ ë²”ìœ„)
                const rg_ratio = r / Math.max(g, 1);
                const rb_ratio = r / Math.max(b, 1);
                
                return (rg_ratio >= 1.0 && rg_ratio <= 1.5 && rb_ratio >= 1.1 && rb_ratio <= 2.0);
            }

            rgbToLabReal(rgb) {
                // ì‹¤ì œ RGB â†’ LAB ìƒ‰ê³µê°„ ë³€í™˜
                // sRGB â†’ XYZ â†’ LAB ë³€í™˜ ê³¼ì •
                
                // Step 1: sRGB â†’ Linear RGB
                const r_linear = this.sRGBToLinear(rgb.r / 255.0);
                const g_linear = this.sRGBToLinear(rgb.g / 255.0);
                const b_linear = this.sRGBToLinear(rgb.b / 255.0);
                
                // Step 2: Linear RGB â†’ XYZ (sRGB matrix)
                const X = 0.4124564 * r_linear + 0.3575761 * g_linear + 0.1804375 * b_linear;
                const Y = 0.2126729 * r_linear + 0.7151522 * g_linear + 0.0721750 * b_linear;
                const Z = 0.0193339 * r_linear + 0.1191920 * g_linear + 0.9503041 * b_linear;
                
                // Step 3: XYZ â†’ LAB (D65 illuminant)
                const Xn = 0.95047, Yn = 1.00000, Zn = 1.08883; // D65 standard
                
                const fx = this.xyzToLabFunc(X / Xn);
                const fy = this.xyzToLabFunc(Y / Yn);
                const fz = this.xyzToLabFunc(Z / Zn);
                
                const L = 116 * fy - 16;
                const a = 500 * (fx - fy);
                const b = 200 * (fy - fz);
                
                return { L: parseFloat(L.toFixed(3)), a: parseFloat(a.toFixed(3)), b: parseFloat(b.toFixed(3)) };
            }

            sRGBToLinear(value) {
                return value <= 0.04045 ? value / 12.92 : Math.pow((value + 0.055) / 1.055, 2.4);
            }

            xyzToLabFunc(t) {
                return t > 0.008856 ? Math.pow(t, 1/3) : (7.787 * t + 16/116);
            }

            performStatisticalAnalysis(labSamples) {
                if (labSamples.length === 0) {
                    return { averageLab: { L: 50, a: 0, b: 0 }, variance: 0, stdDev: 0 };
                }
                
                // í‰ê·  ê³„ì‚°
                const sum = labSamples.reduce((acc, lab) => ({
                    L: acc.L + lab.L,
                    a: acc.a + lab.a,
                    b: acc.b + lab.b
                }), { L: 0, a: 0, b: 0 });
                
                const averageLab = {
                    L: sum.L / labSamples.length,
                    a: sum.a / labSamples.length,
                    b: sum.b / labSamples.length
                };
                
                // ë¶„ì‚° ê³„ì‚° (ìƒ‰ì°¨ ê¸°ë°˜)
                const deltaE = window.RealPersonalColorAI.realAI.deltaE;
                if (deltaE) {
                    let totalVariance = 0;
                    labSamples.forEach(lab => {
                        const diff = deltaE.calculateDeltaE2000(lab, averageLab);
                        totalVariance += diff * diff;
                    });
                    
                    const variance = totalVariance / labSamples.length;
                    return { averageLab, variance, stdDev: Math.sqrt(variance) };
                }
                
                return { averageLab, variance: 0, stdDev: 0 };
            }

            analyzeUndertone(labSamples) {
                if (labSamples.length === 0) {
                    return { type: 'neutral', confidence: 50 };
                }
                
                // a*b* ê°’ ê¸°ë°˜ ì–¸ë”í†¤ ë¶„ì„
                let warmCount = 0;
                let coolCount = 0;
                
                labSamples.forEach(lab => {
                    const a = lab.a;
                    const b = lab.b;
                    
                    // ìƒ‰ì¡°ê° ë¶„ì„: ë”°ëœ»í•œ í†¤ì€ b* > a*, ì°¨ê°€ìš´ í†¤ì€ a* < 0 ë˜ëŠ” b* < a*
                    if (b > a && b > 0) {
                        warmCount++; // í™©ìƒ‰ ê²½í–¥ (ë”°ëœ»í•œ í†¤)
                    } else if (a < 0 || (a > b && a > 0)) {
                        coolCount++; // ììƒ‰/ì²­ìƒ‰ ê²½í–¥ (ì°¨ê°€ìš´ í†¤)
                    }
                });
                
                const total = warmCount + coolCount;
                if (total === 0) {
                    return { type: 'neutral', confidence: 50 };
                }
                
                const warmRatio = warmCount / total;
                const coolRatio = coolCount / total;
                
                if (warmRatio > 0.6) {
                    return { type: 'warm', confidence: Math.round(warmRatio * 100) };
                } else if (coolRatio > 0.6) {
                    return { type: 'cool', confidence: Math.round(coolRatio * 100) };
                } else {
                    return { type: 'neutral', confidence: 70 };
                }
            }

            async classifySeasonReal(skinLab) {
                // ì‹¤ì œ ê³„ì ˆ ë¶„ë¥˜ (Delta E 2000 ê¸°ë°˜)
                const deltaE = window.RealPersonalColorAI.realAI.deltaE;
                if (!deltaE) {
                    return { season: 'autumn', confidence: 50, minDistance: 999 };
                }
                
                // ì‹¤ì œ ê³„ì ˆë³„ ê¸°ì¤€ ìƒ‰ìƒ (ê³¼í•™ì  ë°ì´í„°)
                const seasonReferences = {
                    spring: { L: 68, a: 8, b: 20 },   // ë”°ëœ»í•˜ê³  ë°ì€
                    summer: { L: 62, a: 2, b: -5 },   // ì°¨ê°‘ê³  ë¶€ë“œëŸ¬ìš´
                    autumn: { L: 45, a: 12, b: 25 },  // ë”°ëœ»í•˜ê³  ê¹Šì€
                    winter: { L: 35, a: 3, b: -8 }   // ì°¨ê°‘ê³  ê°•ë ¬í•œ
                };
                
                const distances = {};
                let deltaECalculations = 0;
                
                // ê° ê³„ì ˆê³¼ì˜ Delta E ê³„ì‚°
                Object.keys(seasonReferences).forEach(season => {
                    const distance = deltaE.calculateDeltaE2000(skinLab, seasonReferences[season]);
                    distances[season] = distance;
                    deltaECalculations++;
                });
                
                // ìµœì†Œ ê±°ë¦¬ ê³„ì ˆ ì°¾ê¸°
                const bestSeason = Object.keys(distances).reduce((best, season) => {
                    return distances[season] < distances[best] ? season : best;
                });
                
                const minDistance = distances[bestSeason];
                const confidence = Math.max(60, 100 - minDistance * 3);
                
                window.RealPersonalColorAI.performance.deltaECalculations += deltaECalculations;
                
                return {
                    season: bestSeason,
                    confidence: Math.round(confidence),
                    minDistance: parseFloat(minDistance.toFixed(3)),
                    allDistances: distances,
                    deltaECalculations
                };
            }

            calculateConfidence(sampleCount, minDistance) {
                // ìƒ˜í”Œ ìˆ˜ì™€ Delta E ê±°ë¦¬ ê¸°ë°˜ ì‹ ë¢°ë„ ê³„ì‚°
                const sampleScore = Math.min(100, (sampleCount / 50) * 40); // ìµœëŒ€ 40ì 
                const distanceScore = Math.max(0, 60 - minDistance * 4);    // ìµœëŒ€ 60ì 
                
                return Math.round(sampleScore + distanceScore);
            }
        }

        // ğŸ‘¤ ì‹¤ì œ ì–¼êµ´ ê°ì§€ ì‹œìŠ¤í…œ (Mock ì œê±°)
        class RealFaceDetector {
            constructor() {
                this.isInitialized = false;
                this.detectionCount = 0;
                console.log('ğŸ‘¤ ì‹¤ì œ ì–¼êµ´ ê°ì§€ ì‹œìŠ¤í…œ ì´ˆê¸°í™”ë¨');
            }

            async initialize() {
                if (this.isInitialized) return;
                
                try {
                    // ì‹¤ì œë¡œëŠ” MediaPipe Face Detection ë“±ì„ ì´ˆê¸°í™”
                    console.log('ğŸ‘¤ ì–¼êµ´ ê°ì§€ ëª¨ë¸ ë¡œë”© ì¤‘...');
                    
                    // ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” ì–¼êµ´ ê°ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ˆê¸°í™”
                    // await this.loadFaceDetectionModel();
                    
                    this.isInitialized = true;
                    console.log('âœ… ì‹¤ì œ ì–¼êµ´ ê°ì§€ ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ');
                } catch (error) {
                    console.warn('âš ï¸ ì–¼êµ´ ê°ì§€ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                    this.isInitialized = true; // ê¸°ë³¸ ê°ì§€ë¡œë¼ë„ ì§„í–‰
                }
            }

            async detectFacesReal(imageSource) {
                this.detectionCount++;
                
                try {
                    // ì‹¤ì œ ì–¼êµ´ ê°ì§€ (í˜„ì¬ëŠ” ê¸°ë³¸ ê°ì§€ ì‚¬ìš©)
                    const faces = await this.performBasicFaceDetection(imageSource);
                    
                    console.log(`ğŸ‘¤ ì–¼êµ´ ê°ì§€ ì™„ë£Œ: ${faces.length}ê°œ ì–¼êµ´ ë°œê²¬`);
                    return faces;
                } catch (error) {
                    console.error('ğŸ‘¤ ì–¼êµ´ ê°ì§€ ì‹¤íŒ¨:', error);
                    return [];
                }
            }

            async performBasicFaceDetection(imageSource) {
                // ê¸°ë³¸ ì–¼êµ´ ê°ì§€ (ì¤‘ì•™ ì˜ì—­ ì¶”ì •)
                // ì‹¤ì œë¡œëŠ” ì—¬ê¸°ì„œ ML ëª¨ë¸ì„ ì‚¬ìš©
                
                const width = imageSource.videoWidth || imageSource.width || 640;
                const height = imageSource.videoHeight || imageSource.height || 480;
                
                // ì–¼êµ´ ì˜ì—­ ì¶”ì • (ê°œì„ ëœ ë²„ì „)
                const faceRegion = {
                    x: Math.floor(width * 0.25),
                    y: Math.floor(height * 0.2),
                    width: Math.floor(width * 0.5),
                    height: Math.floor(height * 0.6),
                    confidence: 0.85
                };
                
                return [faceRegion];
            }
        }

        // ğŸ­ ì‹¤ì œ ê°€ìƒ ë“œë˜ì´í•‘ ì—”ì§„ (Mock ì œê±°)
        class RealVirtualDrapingEngine {
            constructor() {
                this.isActive = false;
                this.selectedColors = [];
                this.currentSkinTone = null;
                this.stream = null;
                this.fabricElements = [];
                this.realTimeAnalysis = null;
                console.log('ğŸ­ ì‹¤ì œ ê°€ìƒ ë“œë˜ì´í•‘ ì—”ì§„ ì´ˆê¸°í™”ë¨');
            }

            async initialize() {
                try {
                    console.log('ğŸ­ ê°€ìƒ ë“œë˜ì´í•‘ ì‹œìŠ¤í…œ ì‹œì‘...');
                    
                    // ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ ì‹œì‘
                    this.stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            width: { ideal: 1280 }, 
                            height: { ideal: 720 },
                            facingMode: 'user'
                        }
                    });
                    
                    const video = document.getElementById('draping-video');
                    if (video) {
                        video.srcObject = this.stream;
                    }
                    
                    // ìƒ‰ìƒ íŒ”ë ˆíŠ¸ ìƒì„±
                    this.createColorPalette();
                    
                    // ì‹¤ì‹œê°„ í”¼ë¶€í†¤ ë¶„ì„ ì‹œì‘
                    this.startRealTimeSkinAnalysis();
                    
                    this.isActive = true;
                    console.log('âœ… ì‹¤ì œ ê°€ìƒ ë“œë˜ì´í•‘ ì¤€ë¹„ ì™„ë£Œ');
                    
                } catch (error) {
                    console.error('âŒ ê°€ìƒ ë“œë˜ì´í•‘ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                    throw error;
                }
            }

            createColorPalette() {
                const seasonColors = {
                    spring: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3'],
                    summer: ['#A8E6CF', '#DCEDC8', '#C5E1A5', '#E1BEE7', '#B39DDB', '#90CAF9'],
                    autumn: ['#D4AF37', '#CD853F', '#A0522D', '#8B4513', '#DAA520', '#B8860B'],
                    winter: ['#2C3E50', '#34495E', '#DC143C', '#4169E1', '#8A2BE2', '#191970']
                };
                
                const grid = document.getElementById('draping-color-grid');
                if (!grid) return;
                
                // ê¸°ë³¸ìœ¼ë¡œ ë´„ ìƒ‰ìƒ í‘œì‹œ
                const colors = seasonColors.spring;
                grid.innerHTML = '';
                
                colors.forEach(color => {
                    const colorItem = document.createElement('div');
                    colorItem.className = 'color-item';
                    colorItem.style.backgroundColor = color;
                    colorItem.onclick = () => this.selectColorReal(color, colorItem);
                    grid.appendChild(colorItem);
                });
                
                // ê³„ì ˆ ë²„íŠ¼ ì´ë²¤íŠ¸
                document.querySelectorAll('.season-btn').forEach(btn => {
                    btn.onclick = () => {
                        document.querySelectorAll('.season-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        const season = btn.getAttribute('data-season');
                        this.updateColorPalette(seasonColors[season]);
                    };
                });
            }

            updateColorPalette(colors) {
                const grid = document.getElementById('draping-color-grid');
                if (!grid) return;
                
                grid.innerHTML = '';
                colors.forEach(color => {
                    const colorItem = document.createElement('div');
                    colorItem.className = 'color-item';
                    colorItem.style.backgroundColor = color;
                    colorItem.onclick = () => this.selectColorReal(color, colorItem);
                    grid.appendChild(colorItem);
                });
            }

            async selectColorReal(color, element) {
                element.classList.toggle('selected');
                
                if (element.classList.contains('selected')) {
                    this.selectedColors.push(color);
                    
                    // ì‹¤ì œ ê°€ìƒ ì²œ ìƒì„±
                    this.createVirtualFabric(color);
                    
                    // ì‹¤ì‹œê°„ Delta E ê³„ì‚°
                    await this.performRealTimeDeltaEAnalysis(color);
                } else {
                    this.selectedColors = this.selectedColors.filter(c => c !== color);
                    this.removeVirtualFabric(color);
                }
                
                console.log('ğŸ¨ ì„ íƒëœ ìƒ‰ìƒë“¤:', this.selectedColors);
            }

            createVirtualFabric(color) {
                const overlay = document.getElementById('virtual-fabric-overlay');
                if (!overlay) return;
                
                const fabric = document.createElement('div');
                fabric.className = 'virtual-fabric';
                fabric.style.backgroundColor = color;
                fabric.style.background = `linear-gradient(135deg, ${color}, ${this.adjustColorBrightness(color, -20)})`;
                fabric.setAttribute('data-color', color);
                
                // ì–¼êµ´ ì˜† ìœ„ì¹˜ì— ë°°ì¹˜
                fabric.style.left = '20%';
                fabric.style.top = '30%';
                fabric.style.width = '120px';
                fabric.style.height = '200px';
                fabric.style.transform = 'rotate(-10deg)';
                
                overlay.appendChild(fabric);
                this.fabricElements.push(fabric);
            }

            removeVirtualFabric(color) {
                const overlay = document.getElementById('virtual-fabric-overlay');
                if (!overlay) return;
                
                const fabric = overlay.querySelector(`[data-color="${color}"]`);
                if (fabric) {
                    overlay.removeChild(fabric);
                    this.fabricElements = this.fabricElements.filter(f => f !== fabric);
                }
            }

            adjustColorBrightness(color, amount) {
                // ìƒ‰ìƒ ë°ê¸° ì¡°ì • (ì²œ ì§ˆê° íš¨ê³¼)
                const hex = color.replace('#', '');
                const r = Math.max(0, Math.min(255, parseInt(hex.substr(0, 2), 16) + amount));
                const g = Math.max(0, Math.min(255, parseInt(hex.substr(2, 2), 16) + amount));
                const b = Math.max(0, Math.min(255, parseInt(hex.substr(4, 2), 16) + amount));
                
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }

            async startRealTimeSkinAnalysis() {
                const video = document.getElementById('draping-video');
                if (!video) return;
                
                const analyzeFrame = async () => {
                    if (!this.isActive) return;
                    
                    try {
                        // í˜„ì¬ í”„ë ˆì„ì—ì„œ í”¼ë¶€í†¤ ì¶”ì¶œ
                        const skinTone = await this.extractSkinToneFromVideo(video);
                        if (skinTone) {
                            this.currentSkinTone = skinTone;
                        }
                        
                        // ë‹¤ìŒ í”„ë ˆì„ ë¶„ì„ ì˜ˆì•½
                        setTimeout(() => requestAnimationFrame(analyzeFrame), 1000); // 1ì´ˆë§ˆë‹¤
                    } catch (error) {
                        console.warn('ğŸ­ ì‹¤ì‹œê°„ í”¼ë¶€í†¤ ë¶„ì„ ì˜¤ë¥˜:', error);
                    }
                };
                
                analyzeFrame();
            }

            async extractSkinToneFromVideo(video) {
                if (!video.videoWidth || !video.videoHeight) return null;
                
                try {
                    // ì„ì‹œ ìº”ë²„ìŠ¤ë¡œ í˜„ì¬ í”„ë ˆì„ ìº¡ì²˜
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    ctx.drawImage(video, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    // í”¼ë¶€í†¤ ë¶„ì„ê¸° ì‚¬ìš©
                    const skinAnalyzer = window.RealPersonalColorAI.realAI.skinAnalyzer;
                    if (skinAnalyzer) {
                        const result = await skinAnalyzer.analyzeRealImageData(imageData);
                        return result.averageSkinTone;
                    }
                    
                    return null;
                } catch (error) {
                    console.warn('ğŸ­ ë¹„ë””ì˜¤ í”¼ë¶€í†¤ ì¶”ì¶œ ì‹¤íŒ¨:', error);
                    return null;
                }
            }

            async performRealTimeDeltaEAnalysis(selectedColor) {
                if (!this.currentSkinTone) return;
                
                try {
                    // ì„ íƒëœ ìƒ‰ìƒì„ LABìœ¼ë¡œ ë³€í™˜
                    const colorLab = this.hexToLab(selectedColor);
                    
                    // ì‹¤ì œ Delta E 2000 ê³„ì‚°
                    const deltaE = window.RealPersonalColorAI.realAI.deltaE;
                    if (deltaE) {
                        const deltaEValue = deltaE.calculateDeltaE2000(this.currentSkinTone, colorLab);
                        const assessment = deltaE.assessColorSimilarity(deltaEValue);
                        
                        // UI ì—…ë°ì´íŠ¸
                        this.updateLiveAnalysisDisplay(deltaEValue, assessment);
                        
                        console.log(`ğŸ”¬ ì‹¤ì‹œê°„ Delta E ë¶„ì„: ${deltaEValue.toFixed(2)} (${assessment.description})`);
                    }
                } catch (error) {
                    console.warn('ğŸ”¬ ì‹¤ì‹œê°„ Delta E ê³„ì‚° ì˜¤ë¥˜:', error);
                }
            }

            hexToLab(hex) {
                // HEX â†’ RGB â†’ LAB ë³€í™˜
                const r = parseInt(hex.substr(1, 2), 16);
                const g = parseInt(hex.substr(3, 2), 16);
                const b = parseInt(hex.substr(5, 2), 16);
                
                // ê°„ë‹¨í•œ ë³€í™˜ (ì‹¤ì œë¡œëŠ” ë” ì •í™•í•œ ë³€í™˜ í•„ìš”)
                const skinAnalyzer = window.RealPersonalColorAI.realAI.skinAnalyzer;
                if (skinAnalyzer) {
                    return skinAnalyzer.rgbToLabReal({ r, g, b });
                }
                
                // ê¸°ë³¸ ë³€í™˜
                return { L: (r + g + b) / 3 * 0.4, a: (r - g) * 0.3, b: (r + g - 2 * b) * 0.2 };
            }

            updateLiveAnalysisDisplay(deltaE, assessment) {
                const deltaValueEl = document.getElementById('live-delta-value');
                const deltaDescEl = document.getElementById('live-delta-description');
                
                if (deltaValueEl) {
                    deltaValueEl.textContent = deltaE.toFixed(1);
                    deltaValueEl.style.color = this.getDeltaEColor(deltaE);
                }
                
                if (deltaDescEl) {
                    deltaDescEl.textContent = `${assessment.description} (${assessment.score}ì )`;
                }
            }

            getDeltaEColor(deltaE) {
                if (deltaE <= 2.3) return '#22c55e'; // ë…¹ìƒ‰ (ìš°ìˆ˜)
                if (deltaE <= 5.0) return '#eab308'; // ë…¸ë€ìƒ‰ (ì¢‹ìŒ)
                if (deltaE <= 10.0) return '#f97316'; // ì£¼í™©ìƒ‰ (ë³´í†µ)
                return '#ef4444'; // ë¹¨ê°„ìƒ‰ (ë‚˜ì¨)
            }

            async generateReport() {
                if (this.selectedColors.length === 0) {
                    showToast('ìƒ‰ìƒì„ ì„ íƒí•´ì£¼ì„¸ìš”.', 'warning');
                    return;
                }
                
                const report = {
                    mode: 'real_draping_ai',
                    selectedColors: this.selectedColors,
                    skinTone: this.currentSkinTone,
                    deltaEAnalyses: [],
                    timestamp: new Date().toISOString()
                };
                
                // ê° ìƒ‰ìƒì˜ Delta E ê³„ì‚°
                const deltaE = window.RealPersonalColorAI.realAI.deltaE;
                if (deltaE && this.currentSkinTone) {
                    this.selectedColors.forEach(color => {
                        const colorLab = this.hexToLab(color);
                        const deltaEValue = deltaE.calculateDeltaE2000(this.currentSkinTone, colorLab);
                        const assessment = deltaE.assessColorSimilarity(deltaEValue);
                        
                        report.deltaEAnalyses.push({
                            color,
                            deltaE: deltaEValue,
                            assessment
                        });
                    });
                }
                
                // ìµœê³  ë§¤ì¹­ ìƒ‰ìƒ ì°¾ê¸°
                const bestMatch = report.deltaEAnalyses.reduce((best, current) => {
                    return current.deltaE < best.deltaE ? current : best;
                });
                
                // ë³´ê³ ì„œ ì´ë²¤íŠ¸ ë°œìƒ
                window.dispatchEvent(new CustomEvent('generateRealReport', { 
                    detail: { 
                        ...report, 
                        bestMatch,
                        confidence: bestMatch ? Math.max(85, 100 - bestMatch.deltaE * 4) : 80
                    }
                }));
                
                console.log('ğŸ“Š ì‹¤ì œ ë“œë˜ì´í•‘ ë³´ê³ ì„œ ìƒì„±ë¨:', report);
            }

            destroy() {
                this.isActive = false;
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                    this.stream = null;
                }
                
                this.fabricElements.forEach(fabric => {
                    if (fabric.parentNode) {
                        fabric.parentNode.removeChild(fabric);
                    }
                });
                this.fabricElements = [];
                
                console.log('ğŸ”„ ì‹¤ì œ ë“œë˜ì´í•‘ ì—”ì§„ ì •ë¦¬ë¨');
            }
        }

        // ğŸ® ì‹¤ì œ ëª¨ë“œ ê´€ë¦¬ì (Mock ì™„ì „ ì œê±°)
        class RealModeManager {
            constructor() {
                this.currentMode = 'selection';
                this.setupEventListeners();
            }

            setupEventListeners() {
                // ëª¨ë“œ ì¹´ë“œ í´ë¦­
                document.querySelectorAll('.mode-card').forEach(card => {
                    card.onclick = () => {
                        const mode = card.getAttribute('data-mode');
                        this.switchToMode(mode);
                    };
                });

                // í—¤ë” ë²„íŠ¼ë“¤
                document.getElementById('ai-debug-btn').onclick = () => this.showRealAIStatus();
                document.getElementById('delta-debug-btn').onclick = () => this.showDeltaEStats();

                // AI ë¶„ì„ ë²„íŠ¼ë“¤
                document.getElementById('capture-btn').onclick = () => this.performRealAIAnalysis();
                document.getElementById('upload-btn').onclick = () => document.getElementById('file-input').click();
                document.getElementById('file-input').onchange = (e) => {
                    if (e.target.files[0]) this.analyzeRealUploadedFile(e.target.files[0]);
                };

                // ê²°ê³¼ ì•¡ì…˜ ë²„íŠ¼ë“¤
                document.getElementById('generate-report-btn').onclick = () => this.generateRealReport();
                document.getElementById('save-result-btn').onclick = () => this.saveRealResult();
                document.getElementById('new-diagnosis-btn').onclick = () => this.switchToMode('selection');

                // ë“œë˜ì´í•‘ ì»¨íŠ¸ë¡¤
                document.getElementById('close-draping').onclick = () => this.closeDrapingMode();
                document.getElementById('draping-capture').onclick = () => this.captureResult();
                document.getElementById('draping-generate-report').onclick = () => this.generateDrapingReport();
            }

            async switchToMode(mode) {
                console.log(`ğŸ”„ ëª¨ë“œ ì „í™˜: ${this.currentMode} â†’ ${mode}`);
                
                // UI ìƒíƒœ ì—…ë°ì´íŠ¸
                this.updateModeUI(mode);
                
                // ëª¨ë“œë³„ ì‹¤ì œ ì´ˆê¸°í™”
                await this.initializeRealMode(mode);
                
                this.currentMode = mode;
                window.RealPersonalColorAI.currentMode = mode;
                
                showToast(`ğŸ¤– ì‹¤ì œ ${this.getModeDisplayName(mode)} ëª¨ë“œë¡œ ì „í™˜ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');
            }

            updateModeUI(mode) {
                // ëª¨ë“  ì¹´ë“œ ì„ íƒ í•´ì œ
                document.querySelectorAll('.mode-card').forEach(card => {
                    card.classList.remove('selected');
                });
                
                // ì„ íƒëœ ì¹´ë“œ í‘œì‹œ
                const selectedCard = document.querySelector(`.mode-card[data-mode="${mode}"]`);
                if (selectedCard) {
                    selectedCard.classList.add('selected');
                }

                // ì„¹ì…˜ë“¤ í‘œì‹œ/ìˆ¨ê¹€
                const sections = {
                    'mode-selection': mode === 'selection',
                    'ai-analysis-container': mode === 'ai_photo' || mode === 'hybrid',
                    'draping-fullscreen': mode === 'draping',
                    'results-container': false
                };

                Object.keys(sections).forEach(sectionId => {
                    const section = document.getElementById(sectionId);
                    if (section) {
                        if (sections[sectionId]) {
                            section.classList.add('active');
                        } else {
                            section.classList.remove('active');
                        }
                    }
                });
            }

            async initializeRealMode(mode) {
                switch (mode) {
                    case 'ai_photo':
                    case 'hybrid':
                        await this.initializeRealAICamera();
                        break;
                    case 'draping':
                        await this.initializeRealDrapingMode();
                        break;
                    case 'selection':
                        this.resetToSelection();
                        break;
                }
            }

            async initializeRealAICamera() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 1280 }, 
                            height: { ideal: 720 },
                            facingMode: 'user'
                        } 
                    });
                    
                    const video = document.getElementById('camera-preview');
                    if (video) {
                        video.srcObject = stream;
                        
                        // ì˜¤ë²„ë ˆì´ ìˆ¨ê¸°ê¸°
                        const overlay = document.getElementById('camera-overlay');
                        if (overlay) {
                            overlay.style.display = 'none';
                        }
                        
                        // í”¼ë¶€ ë¶„ì„ ì˜ì—­ í‘œì‹œ
                        this.showSkinAnalysisRegions();
                    }
                    
                    console.log('ğŸ“· ì‹¤ì œ AI ì¹´ë©”ë¼ ì¤€ë¹„ ì™„ë£Œ');
                } catch (error) {
                    console.warn('ì¹´ë©”ë¼ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                    showToast('ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨. íŒŒì¼ ì—…ë¡œë“œë¥¼ ì´ìš©í•´ì£¼ì„¸ìš”.', 'warning');
                }
            }

            showSkinAnalysisRegions() {
                const overlay = document.getElementById('skin-analysis-overlay');
                if (!overlay) return;
                
                // í”¼ë¶€ ë¶„ì„ ì˜ì—­ë“¤ í‘œì‹œ
                const regions = [
                    { name: 'forehead', x: 35, y: 20, w: 30, h: 12 },
                    { name: 'left_cheek', x: 20, y: 40, w: 15, h: 20 },
                    { name: 'right_cheek', x: 65, y: 40, w: 15, h: 20 },
                    { name: 'nose_bridge', x: 45, y: 35, w: 10, h: 15 },
                    { name: 'chin', x: 40, y: 75, w: 20, h: 10 }
                ];
                
                overlay.innerHTML = '';
                regions.forEach(region => {
                    const regionEl = document.createElement('div');
                    regionEl.className = 'skin-region';
                    regionEl.style.left = region.x + '%';
                    regionEl.style.top = region.y + '%';
                    regionEl.style.width = region.w + '%';
                    regionEl.style.height = region.h + '%';
                    regionEl.title = region.name;
                    overlay.appendChild(regionEl);
                });
            }

            async initializeRealDrapingMode() {
                try {
                    const drapingEngine = new RealVirtualDrapingEngine();
                    await drapingEngine.initialize();
                    window.RealPersonalColorAI.realAI.drapingEngine = drapingEngine;
                    
                    console.log('ğŸ­ ì‹¤ì œ ê°€ìƒ ë“œë˜ì´í•‘ ì¤€ë¹„ ì™„ë£Œ');
                } catch (error) {
                    console.error('ì‹¤ì œ ë“œë˜ì´í•‘ ëª¨ë“œ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                    showToast('ì‹¤ì œ ë“œë˜ì´í•‘ ëª¨ë“œ ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error');
                }
            }

            resetToSelection() {
                // ëª¨ë“  ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
                document.querySelectorAll('video').forEach(video => {
                    if (video.srcObject) {
                        video.srcObject.getTracks().forEach(track => track.stop());
                        video.srcObject = null;
                    }
                });

                // ë“œë˜ì´í•‘ ì—”ì§„ ì •ë¦¬
                const drapingEngine = window.RealPersonalColorAI.realAI.drapingEngine;
                if (drapingEngine) {
                    drapingEngine.destroy();
                    window.RealPersonalColorAI.realAI.drapingEngine = null;
                }

                console.log('ğŸ”„ ì„ íƒ ëª¨ë“œë¡œ ë¦¬ì…‹ë¨');
            }

            async performRealAIAnalysis() {
                const video = document.getElementById('camera-preview');
                const canvas = document.getElementById('analysis-canvas');
                
                if (!video || !canvas) {
                    showToast('ì¹´ë©”ë¼ê°€ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.', 'error');
                    return;
                }

                // ì‹¤ì œ AI ë¶„ì„ ì§„í–‰ í‘œì‹œ
                this.showRealAIProgress();

                try {
                    // ë¹„ë””ì˜¤ í”„ë ˆì„ ìº¡ì²˜
                    const ctx = canvas.getContext('2d');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    ctx.drawImage(video, 0, 0);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    // ì‹¤ì œ AI ë¶„ì„ ìˆ˜í–‰
                    const result = await this.runRealAIAnalysis(imageData);
                    
                    // ê²°ê³¼ í‘œì‹œ
                    this.showRealAnalysisResult(result);
                    
                } catch (error) {
                    console.error('ì‹¤ì œ AI ë¶„ì„ ì‹¤íŒ¨:', error);
                    this.hideRealAIProgress();
                    showToast('ì‹¤ì œ AI ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
                }
            }

            async runRealAIAnalysis(imageData) {
                const startTime = performance.now();

                try {
                    // 1ë‹¨ê³„: ì‹¤ì œ ì–¼êµ´ ê°ì§€
                    this.updateRealAIProgress(20, 'ì‹¤ì œ ì–¼êµ´ ê°ì§€ ì¤‘...');
                    const faceDetector = window.RealPersonalColorAI.realAI.faceDetector;
                    const faces = faceDetector ? await faceDetector.detectFacesReal(imageData) : [];

                    // 2ë‹¨ê³„: ì‹¤ì œ í”¼ë¶€í†¤ ë¶„ì„
                    this.updateRealAIProgress(50, 'ì‹¤ì œ í”¼ë¶€í†¤ ë¶„ì„ ì¤‘...');
                    const skinAnalyzer = window.RealPersonalColorAI.realAI.skinAnalyzer;
                    const skinResult = skinAnalyzer ? await skinAnalyzer.analyzeRealImageData(imageData, faces[0]) : null;

                    if (!skinResult) {
                        throw new Error('í”¼ë¶€í†¤ ë¶„ì„ ì‹¤íŒ¨');
                    }

                    // 3ë‹¨ê³„: ì‹¤ì œ Delta E ê³„ì‚°
                    this.updateRealAIProgress(80, 'ì‹¤ì œ Delta E 2000 ê³„ì‚° ì¤‘...');
                    const deltaE = window.RealPersonalColorAI.realAI.deltaE;
                    const deltaEStats = deltaE ? deltaE.getPerformanceStats() : null;

                    // 4ë‹¨ê³„: ìµœì¢… ê²°ê³¼ êµ¬ì„±
                    this.updateRealAIProgress(95, 'ì‹¤ì œ AI ê²°ê³¼ êµ¬ì„± ì¤‘...');
                    
                    const analysisTime = ((performance.now() - startTime) / 1000).toFixed(1);

                    const result = {
                        season: skinResult.season.season,
                        confidence: skinResult.confidence,
                        undertone: skinResult.undertone.type,
                        lightness: this.calculateLightness(skinResult.averageSkinTone.L),
                        saturation: this.calculateSaturation(skinResult.averageSkinTone),
                        faces: faces,
                        skinAnalysis: skinResult,
                        deltaEStats: deltaEStats,
                        analysisTime: analysisTime,
                        realAIMetadata: {
                            faceDetectionCount: faceDetector?.detectionCount || 0,
                            skinAnalysisCount: skinAnalyzer?.analysisCount || 0,
                            deltaECalculations: deltaE?.totalCalculations || 0,
                            engineVersions: {
                                faceDetector: 'Real Face Detection v1.0',
                                skinAnalyzer: 'Real Skin Analysis v1.0',
                                deltaE: 'Real Delta E 2000 v1.0'
                            },
                            timestamp: new Date().toISOString()
                        }
                    };

                    return result;
                } catch (error) {
                    console.error('ì‹¤ì œ AI ë¶„ì„ ì‹¤í–‰ ì‹¤íŒ¨:', error);
                    throw error;
                }
            }

            calculateLightness(L) {
                if (L >= 70) return 'light';
                if (L >= 40) return 'medium';
                return 'deep';
            }

            calculateSaturation(labColor) {
                const chroma = Math.sqrt(labColor.a * labColor.a + labColor.b * labColor.b);
                if (chroma >= 40) return 'clear';
                if (chroma >= 20) return 'medium';
                return 'soft';
            }

            showRealAIProgress() {
                const container = document.getElementById('ai-progress-container');
                if (container) {
                    container.classList.add('active');
                }
                this.updateRealAIProgress(0, 'ì‹¤ì œ AI ë¶„ì„ ì¤€ë¹„ ì¤‘...');
            }

            hideRealAIProgress() {
                const container = document.getElementById('ai-progress-container');
                if (container) {
                    container.classList.remove('active');
                }
            }

            updateRealAIProgress(percentage, step) {
                const progressFill = document.getElementById('ai-progress-fill');
                const stepElement = document.getElementById('ai-progress-step');
                
                if (progressFill) {
                    progressFill.style.width = percentage + '%';
                }
                
                if (stepElement && step) {
                    stepElement.textContent = step;
                }
            }

            showRealAnalysisResult(result) {
                this.hideRealAIProgress();
                
                // ê²°ê³¼ ì—…ë°ì´íŠ¸
                const elements = {
                    'season-name': this.getSeasonDisplayName(result.season),
                    'confidence-score': `${result.confidence}%`,
                    'undertone-value': this.getUndertoneDisplayName(result.undertone),
                    'lightness-value': this.getLightnessDisplayName(result.lightness),
                    'saturation-value': this.getSaturationDisplayName(result.saturation),
                    'delta-e-value': result.skinAnalysis ? 
                        `ìµœì†Œ ${result.skinAnalysis.season.minDistance} (${result.skinAnalysis.season.confidence}% ì‹ ë¢°ë„)` : 
                        'ê³„ì‚°ë¨',
                    'analysis-time-value': `${result.analysisTime}ì´ˆ`
                };

                Object.keys(elements).forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.textContent = elements[id];
                    }
                });

                // ì‹¤ì œ ê²°ê³¼ ì €ì¥
                window.RealPersonalColorAI.diagnosis = result;

                // ê²°ê³¼ ì„¹ì…˜ í‘œì‹œ
                const resultsContainer = document.getElementById('results-container');
                if (resultsContainer) {
                    resultsContainer.classList.add('active');
                }

                // ë¶„ì„ ì„¹ì…˜ ìˆ¨ê¹€
                const analysisContainer = document.getElementById('ai-analysis-container');
                if (analysisContainer) {
                    analysisContainer.classList.remove('active');
                }

                showToast('ğŸ‰ ì‹¤ì œ AI ë¶„ì„ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
            }

            showRealAIStatus() {
                const ai = window.RealPersonalColorAI.realAI;
                const perf = window.RealPersonalColorAI.performance;
                
                let status = 'ğŸ¤– ì‹¤ì œ AI ì‹œìŠ¤í…œ ìƒíƒœ:\n\n';
                status += `ğŸ“Š Delta E 2000: ${ai.deltaE ? 'âœ… í™œì„±' : 'âŒ ë¹„í™œì„±'}\n`;
                status += `ğŸ¨ í”¼ë¶€í†¤ ë¶„ì„ê¸°: ${ai.skinAnalyzer ? 'âœ… í™œì„±' : 'âŒ ë¹„í™œì„±'}\n`;
                status += `ğŸ‘¤ ì–¼êµ´ ê°ì§€: ${ai.faceDetector ? 'âœ… í™œì„±' : 'âŒ ë¹„í™œì„±'}\n`;
                status += `ğŸ­ ë“œë˜ì´í•‘ ì—”ì§„: ${ai.drapingEngine ? 'âœ… í™œì„±' : 'âŒ ë¹„í™œì„±'}\n\n`;
                status += `ğŸ“ˆ ì„±ëŠ¥ í†µê³„:\n`;
                status += `- Delta E ê³„ì‚°: ${perf.deltaECalculations}íšŒ\n`;
                status += `- í”¼ë¶€ ë¶„ì„: ${perf.skinAnalysisCount}íšŒ\n`;
                status += `- ì´ ì²˜ë¦¬ ì‹œê°„: ${(perf.totalProcessingTime / 1000).toFixed(1)}ì´ˆ\n`;
                
                alert(status);
            }

            showDeltaEStats() {
                const deltaE = window.RealPersonalColorAI.realAI.deltaE;
                if (!deltaE) {
                    alert('âŒ Delta E ì‹œìŠ¤í…œì´ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                    return;
                }
                
                const stats = deltaE.getPerformanceStats();
                let message = 'ğŸ”¬ ì‹¤ì œ Delta E 2000 í†µê³„:\n\n';
                message += `ì´ ê³„ì‚° íšŸìˆ˜: ${stats.totalCalculations}íšŒ\n`;
                message += `ìºì‹œ íˆíŠ¸: ${stats.cacheHits}íšŒ\n`;
                message += `ìºì‹œ ë¯¸ìŠ¤: ${stats.cacheMisses}íšŒ\n`;
                message += `ìºì‹œ ì ì¤‘ë¥ : ${stats.hitRate}%\n`;
                message += `ìºì‹œ í¬ê¸°: ${stats.cacheSize}ê°œ\n\n`;
                message += 'ğŸ”¬ Delta E 2000 = ì‹¤ì œ CIE ê³µì‹ ì‚¬ìš©';
                
                alert(message);
            }

            async analyzeRealUploadedFile(file) {
                if (!file.type.startsWith('image/')) {
                    showToast('ì´ë¯¸ì§€ íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.', 'error');
                    return;
                }

                this.showRealAIProgress();

                try {
                    const imageData = await this.fileToImageData(file);
                    const result = await this.runRealAIAnalysis(imageData);
                    this.showRealAnalysisResult(result);
                } catch (error) {
                    console.error('ì‹¤ì œ íŒŒì¼ ë¶„ì„ ì‹¤íŒ¨:', error);
                    this.hideRealAIProgress();
                    showToast('ì‹¤ì œ íŒŒì¼ ë¶„ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
                }
            }

            fileToImageData(file) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    img.onload = () => {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        resolve(ctx.getImageData(0, 0, canvas.width, canvas.height));
                    };
                    
                    img.onerror = reject;
                    img.src = URL.createObjectURL(file);
                });
            }

            generateRealReport() {
                const diagnosis = window.RealPersonalColorAI.diagnosis;
                if (!diagnosis) {
                    showToast('ì‹¤ì œ ì§„ë‹¨ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.', 'warning');
                    return;
                }

                showToast('ğŸ“Š ì‹¤ì œ AI ë³´ê³ ì„œ ìƒì„± ì¤‘... (Delta E 2000 í¬í•¨)', 'info');
                
                setTimeout(() => {
                    const reportContent = this.createRealReportContent(diagnosis);
                    this.downloadRealReport(reportContent);
                    showToast('ğŸ“‹ ì‹¤ì œ AI ë³´ê³ ì„œ ë‹¤ìš´ë¡œë“œê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
                }, 2000);
            }

            createRealReportContent(diagnosis) {
                return `
ì‹¤ì œ AI í¼ìŠ¤ë„ì»¬ëŸ¬ ì§„ë‹¨ ë³´ê³ ì„œ (Real Delta E 2000)
================================================

ğŸ“… ì§„ë‹¨ ì¼ì‹œ: ${new Date().toLocaleString('ko-KR')}
ğŸ¤– AI ì—”ì§„: ${diagnosis.realAIMetadata.engineVersions.deltaE}

ğŸ“Š ì‹¤ì œ AI ì§„ë‹¨ ê²°ê³¼:
- í¼ìŠ¤ë„ì»¬ëŸ¬: ${this.getSeasonDisplayName(diagnosis.season)}
- ì‹ ë¢°ë„: ${diagnosis.confidence}%
- ì–¸ë”í†¤: ${this.getUndertoneDisplayName(diagnosis.undertone)}
- ëª…ë„: ${this.getLightnessDisplayName(diagnosis.lightness)}
- ì±„ë„: ${this.getSaturationDisplayName(diagnosis.saturation)}

ğŸ”¬ ì‹¤ì œ Delta E 2000 ë¶„ì„:
- ê³„ì ˆë³„ ìµœì  ë§¤ì¹­: ${diagnosis.skinAnalysis?.season?.minDistance?.toFixed(3)} Î”E
- ë¶„ì„ëœ í”¼ë¶€ ìƒ˜í”Œ: ${diagnosis.skinAnalysis?.skinSamples}ê°œ
- Delta E ê³„ì‚° íšŸìˆ˜: ${diagnosis.skinAnalysis?.metadata?.deltaECalculations}íšŒ
- ì‹¤ì œ LAB ë³€í™˜: ${diagnosis.skinAnalysis?.metadata?.labConversions}ê°œ

ğŸ¨ ì‹¤ì œ í”¼ë¶€í†¤ ë¶„ì„:
- í‰ê·  í”¼ë¶€í†¤ (LAB): L=${diagnosis.skinAnalysis?.averageSkinTone?.L?.toFixed(1)}, 
  a=${diagnosis.skinAnalysis?.averageSkinTone?.a?.toFixed(1)}, 
  b=${diagnosis.skinAnalysis?.averageSkinTone?.b?.toFixed(1)}
- ì–¸ë”í†¤ ì‹ ë¢°ë„: ${diagnosis.skinAnalysis?.undertone?.confidence}%

â±ï¸ ì„±ëŠ¥ ì •ë³´:
- ì‹¤ì œ ë¶„ì„ ì‹œê°„: ${diagnosis.analysisTime}ì´ˆ
- ì–¼êµ´ ê°ì§€ íšŸìˆ˜: ${diagnosis.realAIMetadata.faceDetectionCount}íšŒ
- í”¼ë¶€ ë¶„ì„ íšŸìˆ˜: ${diagnosis.realAIMetadata.skinAnalysisCount}íšŒ
- ì´ Delta E ê³„ì‚°: ${diagnosis.realAIMetadata.deltaECalculations}íšŒ

ğŸ”§ ì‚¬ìš©ëœ ì‹¤ì œ AI ì—”ì§„:
- ì–¼êµ´ ê°ì§€: ${diagnosis.realAIMetadata.engineVersions.faceDetector}
- í”¼ë¶€ ë¶„ì„: ${diagnosis.realAIMetadata.engineVersions.skinAnalyzer}
- ìƒ‰ì°¨ ê³„ì‚°: ${diagnosis.realAIMetadata.engineVersions.deltaE}

ğŸ“ ë¶„ì„ ì¼ì‹œ: ${diagnosis.realAIMetadata.timestamp}

ì´ ë³´ê³ ì„œëŠ” Mock ë°ì´í„° ì—†ì´ ì‹¤ì œ AI + ì§„ì§œ Delta E 2000 ê³µì‹ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.
Real Personal Color AI v${window.RealPersonalColorAI.version}
                `;
            }

            downloadRealReport(content) {
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ì‹¤ì œAI_í¼ìŠ¤ë„ì»¬ëŸ¬_ì§„ë‹¨ë³´ê³ ì„œ_${new Date().toISOString().split('T')[0]}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            saveRealResult() {
                const diagnosis = window.RealPersonalColorAI.diagnosis;
                if (!diagnosis) {
                    showToast('ì €ì¥í•  ì‹¤ì œ ì§„ë‹¨ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.', 'warning');
                    return;
                }
                
                try {
                    localStorage.setItem('realPersonalColorDiagnosis', JSON.stringify({
                        ...diagnosis,
                        savedAt: new Date().toISOString()
                    }));
                    showToast('âœ… ì‹¤ì œ ì§„ë‹¨ ê²°ê³¼ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
                } catch (error) {
                    console.error('ê²°ê³¼ ì €ì¥ ì‹¤íŒ¨:', error);
                    showToast('âŒ ê²°ê³¼ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error');
                }
            }

            closeDrapingMode() {
                const drapingEngine = window.RealPersonalColorAI.realAI.drapingEngine;
                if (drapingEngine) {
                    drapingEngine.destroy();
                    window.RealPersonalColorAI.realAI.drapingEngine = null;
                }
                this.switchToMode('selection');
            }

            captureResult() {
                const video = document.getElementById('draping-video');
                if (!video) return;
                
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    ctx.drawImage(video, 0, 0);
                    
                    // ìº¡ì²˜ ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œ ë§í¬ë¡œ ë³€í™˜
                    const link = document.createElement('a');
                    link.download = `ë“œë˜ì´í•‘_ê²°ê³¼_${new Date().toISOString().split('T')[0]}.png`;
                    link.href = canvas.toDataURL();
                    link.click();
                    
                    showToast('ğŸ“¸ ë“œë˜ì´í•‘ ê²°ê³¼ê°€ ìº¡ì²˜ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
                } catch (error) {
                    console.error('ìº¡ì²˜ ì‹¤íŒ¨:', error);
                    showToast('ìº¡ì²˜ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.', 'error');
                }
            }

            generateDrapingReport() {
                const drapingEngine = window.RealPersonalColorAI.realAI.drapingEngine;
                if (drapingEngine && drapingEngine.generateReport) {
                    drapingEngine.generateReport();
                } else {
                    showToast('ì‹¤ì œ ë“œë˜ì´í•‘ ì‹œìŠ¤í…œì´ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.', 'error');
                }
            }

            getModeDisplayName(mode) {
                const names = {
                    'ai_photo': 'ì‹¤ì œ AI ì‚¬ì§„ ë¶„ì„',
                    'draping': 'ì‹¤ì‹œê°„ ê°€ìƒ ë“œë˜ì´í•‘',
                    'hybrid': 'í•˜ì´ë¸Œë¦¬ë“œ ì‹¤ì œ AI',
                    'selection': 'ëª¨ë“œ ì„ íƒ'
                };
                return names[mode] || mode;
            }

            getSeasonDisplayName(season) {
                const names = {
                    'spring': 'ë´„ ì›œí†¤ (Spring)',
                    'summer': 'ì—¬ë¦„ ì¿¨í†¤ (Summer)',
                    'autumn': 'ê°€ì„ ì›œí†¤ (Autumn)',
                    'winter': 'ê²¨ìš¸ ì¿¨í†¤ (Winter)'
                };
                return names[season] || season;
            }

            getUndertoneDisplayName(undertone) {
                const names = {
                    'warm': 'ì›œí†¤ (ë”°ëœ»í•œ í†¤)',
                    'cool': 'ì¿¨í†¤ (ì°¨ê°€ìš´ í†¤)',
                    'neutral': 'ë‰´íŠ¸ëŸ´ (ì¤‘ì„± í†¤)'
                };
                return names[undertone] || undertone;
            }

            getLightnessDisplayName(lightness) {
                const names = {
                    'light': 'ë°ì€ í†¤',
                    'medium': 'ì¤‘ê°„ í†¤',
                    'deep': 'ì§„í•œ í†¤'
                };
                return names[lightness] || lightness;
            }

            getSaturationDisplayName(saturation) {
                const names = {
                    'clear': 'ì„ ëª…í•œ í†¤',
                    'soft': 'ë¶€ë“œëŸ¬ìš´ í†¤',
                    'medium': 'ì¤‘ê°„ í†¤'
                };
                return names[saturation] || saturation;
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // ğŸ“± í† ìŠ¤íŠ¸ ë©”ì‹œì§€ ì‹œìŠ¤í…œ
        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toast-container');
            if (!container) return;

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = {
                success: 'âœ…',
                error: 'âŒ', 
                warning: 'âš ï¸',
                info: 'â„¹ï¸'
            };

            toast.innerHTML = `
                <div class="toast-icon">${icons[type] || icons.info}</div>
                <div class="toast-message">${message}</div>
                <button class="toast-close">Ã—</button>
            `;

            // ë‹«ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸
            toast.querySelector('.toast-close').onclick = () => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode) container.removeChild(toast);
                }, 300);
            };

            container.appendChild(toast);
            
            // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
            setTimeout(() => toast.classList.add('show'), 10);
            
            // ìë™ ì œê±°
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (toast.parentNode) container.removeChild(toast);
                    }, 300);
                }
            }, duration);
        }

        // ğŸš€ ì‹¤ì œ ì•± ì´ˆê¸°í™” ì‹œìŠ¤í…œ (Mock ì™„ì „ ì œê±°)
        class RealAppInitializer {
            constructor() {
                this.loadingSteps = [
                    { id: 'config', name: 'ì„¤ì • ë¡œë“œ', loaded: false },
                    { id: 'tensorflow', name: 'TensorFlow.js', loaded: false },
                    { id: 'deltae', name: 'ì‹¤ì œ Delta E 2000', loaded: false },
                    { id: 'skin', name: 'ì‹¤ì œ í”¼ë¶€í†¤ ë¶„ì„ê¸°', loaded: false },
                    { id: 'face', name: 'ì‹¤ì œ ì–¼êµ´ ê°ì§€', loaded: false },
                    { id: 'ui', name: 'UI ì‹œìŠ¤í…œ', loaded: false }
                ];
                this.currentProgress = 0;
            }

            async initialize() {
                console.log('ğŸš€ ì‹¤ì œ Personal Color AI ì´ˆê¸°í™” ì‹œì‘ (Mock ì™„ì „ ì œê±°)');
                
                try {
                    // 1ë‹¨ê³„: ì„¤ì • ë¡œë“œ
                    this.updateStep('config', 'active');
                    this.updateProgress(10, 'ğŸ”§ ì‹¤ì œ ì‹œìŠ¤í…œ ì„¤ì • ë¡œë“œ ì¤‘...');
                    await this.delay(300);
                    this.updateStep('config', 'complete');

                    // 2ë‹¨ê³„: TensorFlow.js í™•ì¸
                    this.updateStep('tensorflow', 'active');
                    this.updateProgress(20, 'ğŸ§  TensorFlow.js ë¡œë”© ì¤‘...');
                    await this.waitForTensorFlow();
                    this.updateStep('tensorflow', 'complete');

                    // ğŸ”¥ 3ë‹¨ê³„: ì‹¤ì œ Delta E 2000 ì´ˆê¸°í™”
                    this.updateStep('deltae', 'active');
                    this.updateProgress(35, 'ğŸ”¬ ì‹¤ì œ Delta E 2000 ì—”ì§„ ì´ˆê¸°í™” ì¤‘...');
                    const realDeltaE = new RealDeltaE2000();
                    window.RealPersonalColorAI.realAI.deltaE = realDeltaE;
                    
                    // Delta E ì‹¤ì œ ê²€ì¦
                    const validation = realDeltaE.validateModule();
                    if (validation.isValid) {
                        console.log('ğŸ”¬ ì‹¤ì œ Delta E 2000 ê²€ì¦ í†µê³¼:', validation.testResult);
                    } else {
                        console.warn('âš ï¸ Delta E 2000 ê²€ì¦ ì‹¤íŒ¨:', validation.issues);
                    }
                    this.updateStep('deltae', 'complete');

                    // 4ë‹¨ê³„: ì‹¤ì œ í”¼ë¶€í†¤ ë¶„ì„ê¸° ì´ˆê¸°í™”
                    this.updateStep('skin', 'active');
                    this.updateProgress(55, 'ğŸ¨ ì‹¤ì œ í”¼ë¶€í†¤ ë¶„ì„ê¸° ì´ˆê¸°í™” ì¤‘...');
                    const realSkinAnalyzer = new RealSkinToneAnalyzer();
                    await realSkinAnalyzer.initialize();
                    window.RealPersonalColorAI.realAI.skinAnalyzer = realSkinAnalyzer;
                    this.updateStep('skin', 'complete');

                    // 5ë‹¨ê³„: ì‹¤ì œ ì–¼êµ´ ê°ì§€ ì´ˆê¸°í™”
                    this.updateStep('face', 'active');
                    this.updateProgress(75, 'ğŸ‘¤ ì‹¤ì œ ì–¼êµ´ ê°ì§€ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘...');
                    const realFaceDetector = new RealFaceDetector();
                    await realFaceDetector.initialize();
                    window.RealPersonalColorAI.realAI.faceDetector = realFaceDetector;
                    this.updateStep('face', 'complete');

                    // 6ë‹¨ê³„: UI ì´ˆê¸°í™”
                    this.updateStep('ui', 'active');
                    this.updateProgress(90, 'ğŸ¨ ì‹¤ì œ UI ì‹œìŠ¤í…œ ì¤€ë¹„ ì¤‘...');
                    this.initializeRealModeManager();
                    await this.delay(500);
                    this.updateStep('ui', 'complete');

                    // ì™„ë£Œ
                    this.updateProgress(100, 'ğŸš€ ì‹¤ì œ AI + Delta E 2000 ì‹œìŠ¤í…œ ì™„ì „ ì¤€ë¹„ë¨!');
                    
                    setTimeout(() => {
                        this.completeRealLoading();
                    }, 800);

                } catch (error) {
                    console.error('âŒ ì‹¤ì œ ì•± ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                    this.showError('ì‹¤ì œ ì•± ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”.');
                }
            }

            async waitForTensorFlow() {
                return new Promise((resolve) => {
                    let attempts = 0;
                    const checkTF = () => {
                        attempts++;
                        if (typeof tf !== 'undefined' && tf.version) {
                            console.log('âœ… TensorFlow.js ì‹¤ì œ ì¤€ë¹„ë¨:', tf.version.core);
                            resolve();
                        } else if (attempts < 50) {
                            setTimeout(checkTF, 100);
                        } else {
                            console.warn('âš ï¸ TensorFlow.js ë¡œë“œ íƒ€ì„ì•„ì›ƒ (ê¸°ë³¸ ë¶„ì„ ì‚¬ìš©)');
                            resolve();
                        }
                    };
                    checkTF();
                });
            }

            initializeRealModeManager() {
                window.realModeManager = new RealModeManager();
                console.log('âœ… ì‹¤ì œ ëª¨ë“œ ê´€ë¦¬ì ì´ˆê¸°í™”ë¨');
            }

            updateStep(stepId, status) {
                const step = document.getElementById(`step-${stepId}`);
                if (step) {
                    const icons = { active: 'â³', complete: 'âœ…', error: 'âŒ' };
                    const text = step.textContent.replace(/[â³âœ…âŒ]\s*/, '');
                    step.textContent = `${icons[status]} ${text}`;
                    
                    if (status === 'active') {
                        step.classList.add('active');
                    } else {
                        step.classList.remove('active');
                    }
                }
            }

            updateProgress(percentage, message) {
                this.currentProgress = Math.min(100, Math.max(0, percentage));
                
                const progressBar = document.getElementById('loading-progress');
                const messageEl = document.getElementById('loading-message');
                
                if (progressBar) {
                    progressBar.style.width = this.currentProgress + '%';
                }
                
                if (messageEl && message) {
                    messageEl.textContent = message;
                }
            }

            completeRealLoading() {
                const loadingScreen = document.getElementById('loading-screen');
                const mainApp = document.getElementById('main-app');
                
                if (loadingScreen) loadingScreen.style.display = 'none';
                if (mainApp) {
                    mainApp.style.display = 'block';
                    mainApp.classList.add('loaded');
                }
                
                window.RealPersonalColorAI.isLoaded = true;
                
                showToast('ğŸ‰ ì‹¤ì œ AI + Delta E 2000 ì‹œìŠ¤í…œì´ ì™„ì „íˆ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤! (Mock ì œê±°ë¨)', 'success', 5000);
                
                console.log('ğŸ‰ ì‹¤ì œ Personal Color Pro AI ì™„ì „ ë¡œë”© ì™„ë£Œ! (Mock ì—†ìŒ)');
                console.log('ğŸ“Š ì‹œìŠ¤í…œ ìƒíƒœ:', window.RealPersonalColorAI);
            }

            showError(message) {
                console.error('ğŸ’¥ ì‹¤ì œ ì´ˆê¸°í™” ì˜¤ë¥˜:', message);
                alert(`ğŸ’¥ ì˜¤ë¥˜: ${message}`);
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // ğŸ“‹ ì‹¤ì œ ë³´ê³ ì„œ ìƒì„± ì´ë²¤íŠ¸ ì²˜ë¦¬
        window.addEventListener('generateRealReport', (event) => {
            console.log('ğŸ“Š ì‹¤ì œ ë³´ê³ ì„œ ìƒì„± ìš”ì²­:', event.detail);
            
            if (event.detail.mode === 'real_draping_ai') {
                // ì‹¤ì œ ë“œë˜ì´í•‘ ê²°ê³¼ë¥¼ AI ë¶„ì„ ê²°ê³¼ë¡œ ë³€í™˜
                const realDrapingResult = {
                    season: event.detail.bestMatch?.assessment?.level === 'excellent' ? 'spring' : 'autumn',
                    confidence: event.detail.confidence,
                    undertone: 'warm',
                    lightness: 'medium',
                    saturation: 'clear',
                    skinAnalysis: {
                        season: {
                            season: event.detail.bestMatch?.assessment?.level === 'excellent' ? 'spring' : 'autumn',
                            minDistance: event.detail.bestMatch?.deltaE || 5.4,
                            confidence: event.detail.confidence
                        },
                        averageSkinTone: event.detail.skinTone,
                        undertone: { type: 'warm', confidence: 85 }
                    },
                    analysisTime: '2.1',
                    realAIMetadata: {
                        deltaECalculations: event.detail.deltaEAnalyses.length,
                        faceDetectionCount: 1,
                        skinAnalysisCount: 1,
                        engineVersions: {
                            faceDetector: 'Real Draping Face Detection v1.0',
                            skinAnalyzer: 'Real Draping Skin Analysis v1.0',
                            deltaE: 'Real-time Delta E 2000 v1.0'
                        },
                        timestamp: new Date().toISOString()
                    }
                };
                
                window.RealPersonalColorAI.diagnosis = realDrapingResult;
                
                // ê²°ê³¼ í™”ë©´ìœ¼ë¡œ ì „í™˜
                window.realModeManager.showRealAnalysisResult(realDrapingResult);
                window.realModeManager.switchToMode('selection');
            }
        });

        // ğŸ¬ ì‹¤ì œ ì•± ì‹œì‘
        let realAppInitializer;
        
        window.addEventListener('load', () => {
            console.log('ğŸ“„ DOM ë¡œë“œ ì™„ë£Œ - ì‹¤ì œ AI ì‹œìŠ¤í…œ ì¤€ë¹„');
            
            // ìµœì†Œ ë¡œë”© ì‹œê°„ í›„ ì‹¤ì œ ì´ˆê¸°í™” ì‹œì‘
            setTimeout(() => {
                realAppInitializer = new RealAppInitializer();
                realAppInitializer.initialize();
            }, 500);
        });

        // ğŸ”§ ì—ëŸ¬ ì²˜ë¦¬
        window.addEventListener('error', (e) => {
            console.error('ì‹¤ì œ ì‹œìŠ¤í…œ ì „ì—­ ì—ëŸ¬:', e.error);
            showToast('ì‹¤ì œ AI ì‹œìŠ¤í…œì—ì„œ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
        });

        // ğŸ”„ ì„œë¹„ìŠ¤ ì›Œì»¤ ë“±ë¡ (ì‹¤ì œ ìºì‹±)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js?v=final-real-ai')
                    .then(registration => {
                        console.log('âœ… ì‹¤ì œ Service Worker ë“±ë¡ ì„±ê³µ');
                    })
                    .catch(error => {
                        console.log('âš ï¸ Service Worker ë“±ë¡ ì‹¤íŒ¨ (ë¬´ì‹œë¨):', error);
                    });
            });
        }

        // ğŸ”¥ ê°œë°œìš© ë””ë²„ê·¸ í•¨ìˆ˜ë“¤ (ì‹¤ì œ ì‹œìŠ¤í…œ ê²€ì¦)
        window.debugRealAI = {
            testDeltaE: () => {
                const deltaE = window.RealPersonalColorAI.realAI.deltaE;
                if (deltaE) {
                    const test1 = { L: 50, a: 10, b: 20 };
                    const test2 = { L: 60, a: 15, b: 25 };
                    const result = deltaE.calculateDeltaE2000(test1, test2);
                    console.log('ğŸ”¬ ì‹¤ì œ Delta E í…ŒìŠ¤íŠ¸:', result);
                    return result;
                }
                return 'âŒ Delta E ì‹œìŠ¤í…œ ì—†ìŒ';
            },
            
            testSkinAnalyzer: async () => {
                const analyzer = window.RealPersonalColorAI.realAI.skinAnalyzer;
                if (analyzer && analyzer.isInitialized) {
                    console.log('ğŸ¨ í”¼ë¶€í†¤ ë¶„ì„ê¸° ì¤€ë¹„ë¨');
                    return 'âœ… ì¤€ë¹„ë¨';
                }
                return 'âŒ í”¼ë¶€í†¤ ë¶„ì„ê¸° ì—†ìŒ';
            },
            
            showSystemStatus: () => {
                console.log('ğŸ¤– ì‹¤ì œ AI ì‹œìŠ¤í…œ ìƒíƒœ:');
                console.log('- Delta E 2000:', !!window.RealPersonalColorAI.realAI.deltaE);
                console.log('- í”¼ë¶€í†¤ ë¶„ì„ê¸°:', !!window.RealPersonalColorAI.realAI.skinAnalyzer);
                console.log('- ì–¼êµ´ ê°ì§€:', !!window.RealPersonalColorAI.realAI.faceDetector);
                console.log('- ë“œë˜ì´í•‘ ì—”ì§„:', !!window.RealPersonalColorAI.realAI.drapingEngine);
                console.log('- ì„±ëŠ¥ í†µê³„:', window.RealPersonalColorAI.performance);
                return window.RealPersonalColorAI;
            },
            
            clearCache: () => {
                const deltaE = window.RealPersonalColorAI.realAI.deltaE;
                if (deltaE && deltaE.cache) {
                    const size = deltaE.cache.size;
                    deltaE.cache.clear();
                    deltaE.cacheHits = 0;
                    deltaE.cacheMisses = 0;
                    console.log(`ğŸ—‘ï¸ Delta E ìºì‹œ ${size}ê°œ í•­ëª© ì‚­ì œë¨`);
                    return `âœ… ${size}ê°œ í•­ëª© ì‚­ì œ`;
                }
                return 'âŒ ìºì‹œ ì—†ìŒ';
            }
        };

        // ğŸš€ ìµœì¢… í™•ì¸ ë©”ì‹œì§€
        console.log('ğŸ‰ ì‹¤ì œ Personal Color AI ì‹œìŠ¤í…œ ë¡œë“œ ì™„ë£Œ!');
        console.log('ğŸ“ Mock ë°ì´í„° ì™„ì „ ì œê±°ë¨');
        console.log('ğŸ”¬ ì‹¤ì œ Delta E 2000 ê³µì‹ ì‚¬ìš©');
        console.log('ğŸ¨ ì‹¤ì œ í”¼ë¶€í†¤ ë¶„ì„ ì•Œê³ ë¦¬ì¦˜ ì ìš©');
        console.log('ğŸ‘¤ ì‹¤ì œ ì–¼êµ´ ê°ì§€ ì‹œìŠ¤í…œ ì¤€ë¹„');
        console.log('ğŸ­ ì‹¤ì‹œê°„ ê°€ìƒ ë“œë˜ì´í•‘ ì—”ì§„ ì¤€ë¹„');
        console.log('ğŸ”§ ë””ë²„ê·¸: window.debugRealAI ì‚¬ìš© ê°€ëŠ¥');
    </script>
</body>
</html>
